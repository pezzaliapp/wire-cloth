<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>Wire Cloth + Afro Groove (Hybrid) + Stereo WAV REC</title>
  <style>
    :root{
      --bg:#050805;
      --g: rgba(120,255,140,0.85);
      --g2: rgba(120,255,140,0.28);
      --hudbg: rgba(0,0,0,.30);
      --bd: rgba(182,255,191,.22);
      --txt:#b6ffbf;
      --txt2:#d7ffdd;
      --err:#ffd2d2;
    }
    html,body{
      margin:0;height:100%;
      background:var(--bg);
      overflow:hidden;
      overscroll-behavior:none;
      -webkit-text-size-adjust:100%;
    }
    canvas{
      display:block;width:100vw;height:100vh;
      touch-action:none;
      -webkit-tap-highlight-color: transparent;
    }

    .hud{
      position:fixed;
      left:12px; top:12px;
      z-index:20;
      font:12px/1.35 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;
      color:var(--txt);
      user-select:none;
      background:var(--hudbg);
      padding:10px 12px;
      border-radius:14px;
      border:1px solid var(--bd);
      max-width:min(680px, calc(100vw - 24px));
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .hud b{color:var(--txt2)}
    .row{margin-top:8px;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .sp{flex:1}
    .desc{opacity:.95}

    .btn{
      display:inline-flex;align-items:center;justify-content:center;
      padding:9px 12px;border-radius:13px;
      border:1px solid rgba(182,255,191,.25);
      background:rgba(0,0,0,.25);
      color:var(--txt2);
      cursor:pointer;
      min-height:40px;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }
    .btn.small{padding:7px 10px;border-radius:12px;min-height:34px;font-size:12px;opacity:.96}
    .btn.active{background:rgba(120,255,140,.25)}
    .btn.rec{border-color:rgba(255,120,120,.35)}
    .btn.rec.active{background:rgba(255,120,120,.22)}

    .seg{
      display:inline-flex;border:1px solid rgba(182,255,191,.22);
      border-radius:12px;overflow:hidden;
      background:rgba(0,0,0,.20);
    }
    .seg .btn{
      border:none;border-right:1px solid rgba(182,255,191,.16);
      border-radius:0; min-height:34px; padding:7px 10px;
      background:transparent;
    }
    .seg .btn:last-child{border-right:none}
    .seg .btn.active{background:rgba(120,255,140,.22)}

    label{opacity:.9}
    input[type="range"]{
      width:170px;
      -webkit-appearance:none;appearance:none;
      height:6px;border-radius:999px;
      background:rgba(182,255,191,.25);
      outline:none;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;appearance:none;
      width:20px;height:20px;border-radius:50%;
      background:#d7ffdd;border:1px solid rgba(0,0,0,.4);
    }

    .mini{opacity:.88}
    .err{margin-top:6px;color:var(--err);opacity:.95;white-space:pre-wrap}

    .menuBtn{
      width:44px; height:44px;
      border-radius:14px;
      display:inline-flex;align-items:center;justify-content:center;
      border:1px solid rgba(182,255,191,.20);
      background:rgba(0,0,0,.22);
      cursor:pointer;
    }
    .menuBtn span{font-size:18px;line-height:1;color:var(--txt2);opacity:.9}

    .advanced{display:none}
    .advanced.open{display:block}

    @media (max-width: 480px){
      .hud{left:10px;top:10px;padding:10px 10px;font-size:12px}
      input[type="range"]{width:140px}
      .row{gap:6px}
      .btn{padding:9px 10px}
      .mini{display:none}
    }

    /* Landscape telefoni: HUD più compatto, descrizione nascosta */
    @media (max-height: 430px){
      .hud{max-width:min(560px, calc(100vw - 24px))}
      .desc{display:none}
      .mini{display:none}
      input[type="range"]{width:130px}
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud" id="hud">
    <div class="row" style="margin-top:0">
      <b>Wire Cloth + Afro Groove</b>
      <div class="sp"></div>
      <div class="menuBtn" id="menuBtn" aria-label="Menu"><span>≡</span></div>
    </div>

    <div class="desc">
      Hold & drag = crea vuoti + groove (ovunque) • Band bassa = editor preciso<br>
      Tap sulla band = toggle cella • Shift = taglia • Doppio tap/click = reset
    </div>

    <div class="row">
      <span class="btn" id="audioBtn">▶ AUDIO</span>
      <span class="btn small" id="eraseBtn">ERASE: OFF</span>
      <span class="btn small rec" id="recBtn">● REC WAV</span>
      <span class="btn small rec" id="stopRecBtn" style="display:none;">■ STOP</span>
      <span class="sp"></span>
      <span class="btn small" id="afroBtn">AFRO</span>
      <span class="btn small" id="clearBtn">CLEAR</span>
      <span class="btn small" id="resetBtn">RESET</span>
    </div>

    <div class="row">
      <label>BPM <span id="bpmOut">115</span></label>
      <input id="bpm" type="range" min="105" max="132" step="1" value="115" />
      <label>Swing <span id="swOut">0.58</span></label>
      <input id="sw" type="range" min="0.50" max="0.64" step="0.01" value="0.58" />
    </div>

    <div class="row">
      <label>Band</label>
      <div class="seg" id="bandSeg">
        <span class="btn small" data-band="S">S</span>
        <span class="btn small active" data-band="M">M</span>
        <span class="btn small" data-band="L">L</span>
      </div>
      <span class="mini">K/C/S/G/B = Kick/Clap/Shaker/conGa/Bass</span>
    </div>

    <div class="advanced" id="advanced">
      <div class="row">
        <label>React <span id="reOut">55</span></label>
        <input id="re" type="range" min="10" max="95" step="1" value="55" />
        <label>Trail <span id="trOut">70</span></label>
        <input id="tr" type="range" min="0" max="95" step="1" value="70" />
        <label>Glow <span id="glOut">55</span></label>
        <input id="gl" type="range" min="10" max="95" step="1" value="55" />
      </div>
      <div class="row mini">iPhone: premi AUDIO (gesture), poi REC. In landscape usa ≡ per Advanced.</div>
    </div>

    <div class="err" id="err"></div>
  </div>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);

  const canvas = $("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  const hud = $("hud");
  const errBox = $("err");

  const menuBtn = $("menuBtn");
  const advanced = $("advanced");

  const audioBtn = $("audioBtn");
  const eraseBtn = $("eraseBtn");
  const recBtn = $("recBtn");
  const stopRecBtn = $("stopRecBtn");
  const afroBtn = $("afroBtn");
  const clearBtn = $("clearBtn");
  const resetBtn = $("resetBtn");

  const bpmSlider = $("bpm");
  const bpmOut = $("bpmOut");
  const swSlider = $("sw");
  const swOut = $("swOut");

  const reSlider = $("re");
  const reOut = $("reOut");
  const trSlider = $("tr");
  const trOut = $("trOut");
  const glSlider = $("gl");
  const glOut = $("glOut");

  const bandSeg = $("bandSeg");

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const logErr = (m)=>{ errBox.textContent = m ? String(m) : ""; };

  // Mostra errori JS in HUD (così capiamo subito cosa si rompe)
  window.addEventListener("error", (e)=>logErr("JS error: " + (e.message || e.error || e)));
  window.addEventListener("unhandledrejection", (e)=>logErr("Promise error: " + (e.reason || e)));

  // HUD: i click DEVONO funzionare e NON devono disegnare sul canvas dietro
  ["pointerdown","pointermove","pointerup","click","touchstart","touchmove","touchend"].forEach(ev=>{
    hud.addEventListener(ev, (e)=>{ e.stopPropagation(); }, {passive:false});
  });

  menuBtn.addEventListener("click", (e)=>{
    e.preventDefault(); e.stopPropagation();
    advanced.classList.toggle("open");
  });

  // ---------- Viewport robusto ----------
  let W=0,H=0,DPR=1;
  function getVW(){ return window.visualViewport ? Math.round(window.visualViewport.width) : (innerWidth|0); }
  function getVH(){ return window.visualViewport ? Math.round(window.visualViewport.height) : (innerHeight|0); }
  function resizeCanvas(){
    DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
    W = getVW(); H = getVH();
    canvas.width = (W*DPR)|0;
    canvas.height = (H*DPR)|0;
    canvas.style.width = W+"px";
    canvas.style.height = H+"px";
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }

  window.addEventListener("resize", ()=>{
    resizeCanvas();
    rebuildCloth(); // NON tocca il pattern
  });
  if(window.visualViewport){
    window.visualViewport.addEventListener("resize", ()=>{
      resizeCanvas();
      rebuildCloth();
    });
  }
  resizeCanvas();

  // ---------- FX ----------
  let react = 0.55, trail = 0.70, glow = 0.55;
  function syncFX(){
    react = (+reSlider.value)/100; reOut.textContent = reSlider.value;
    trail = (+trSlider.value)/100; trOut.textContent = trSlider.value;
    glow  = (+glSlider.value)/100; glOut.textContent = glSlider.value;
  }
  reSlider.addEventListener("input", syncFX);
  trSlider.addEventListener("input", syncFX);
  glSlider.addEventListener("input", syncFX);
  syncFX();

  // ---------- Groove ----------
  const STEPS = 16;
  const TRACKS = 5; // K,C,S,G,B

  let bpm = 115;         // DEFAULT richiesto
  let swing = 0.58;

  bpmSlider.value = bpm;
  bpmOut.textContent = bpm;
  swOut.textContent = swing.toFixed(2);

  bpmSlider.addEventListener("input", ()=>{ bpm = +bpmSlider.value; bpmOut.textContent = bpm; });
  swSlider.addEventListener("input", ()=>{ swing = +swSlider.value; swOut.textContent = swing.toFixed(2); });

  const pattern = Array.from({length: TRACKS}, ()=> Array(STEPS).fill(0));

  function seedAfro(){
    for(let r=0;r<TRACKS;r++) pattern[r].fill(0);
    [0,3,7,8,11,14].forEach(s => pattern[0][s] = 1);           // K
    [4,12,15].forEach(s => pattern[1][s] = 1);                 // C
    [1,2,3,5,6,7,9,10,11,13,14,15].forEach(s => pattern[2][s] = 1); // S
    [2,6,10,13].forEach(s => pattern[3][s] = 1);               // G
    [0,7,10,15].forEach(s => pattern[4][s] = 1);               // B
  }
  seedAfro();

  afroBtn.addEventListener("click", ()=>seedAfro());
  clearBtn.addEventListener("click", ()=>{ for(let r=0;r<TRACKS;r++) pattern[r].fill(0); });
  resetBtn.addEventListener("click", ()=>{ seedAfro(); rebuildCloth(true); });

  // ---------- Band S/M/L (FIX: non chiamare setBandPreset prima che bandSeg esista) ----------
  const BAND_SCALE = { S:0.28, M:0.34, L:0.42 };
  let bandPreset = localStorage.getItem("bandPreset") || "M";

  function markBandButtons(){
    [...bandSeg.querySelectorAll("[data-band]")].forEach(b=>{
      b.classList.toggle("active", b.dataset.band === bandPreset);
    });
  }
  function setBandPreset(p){
    bandPreset = p;
    localStorage.setItem("bandPreset", p);
    markBandButtons();
    rebuildCloth(); // aggiorna geometrie
  }
  markBandButtons();

  bandSeg.addEventListener("click", (e)=>{
    const t = e.target.closest("[data-band]");
    if(!t) return;
    e.preventDefault(); e.stopPropagation();
    setBandPreset(t.dataset.band);
  });

  function grooveBandRect(){
    const base = BAND_SCALE[bandPreset] ?? 0.34;
    const isLandscape = W > H;
    const scale = isLandscape ? Math.min(0.52, base + 0.06) : base;
    const h = clamp((H*scale)|0, 110, isLandscape ? 220 : 260);
    return { x: 14, y: H - h - 14, w: W - 28, h };
  }

  // ---------- Cloth ----------
  let COLS=50, ROWS=28, SPACING=16;
  let GRAV=0.42, FRICTION=0.992;
  let ITER=5, TEAR_DIST=32;
  let FIELD_R=80, FIELD_STRENGTH=2.8, CUT_RADIUS=18;

  class Point{
    constructor(x,y,pinned=false){ this.x=x; this.y=y; this.px=x; this.py=y; this.pinned=pinned; }
    verlet(){
      if(this.pinned) return;
      const vx=(this.x-this.px)*FRICTION;
      const vy=(this.y-this.py)*FRICTION;
      this.px=this.x; this.py=this.y;
      this.x += vx;
      this.y += vy + GRAV;
    }
  }
  class Link{
    constructor(a,b,rest){ this.a=a; this.b=b; this.rest=rest; this.active=true; }
    satisfy(){
      if(!this.active) return;
      const dx=this.b.x-this.a.x, dy=this.b.y-this.a.y;
      const d=Math.hypot(dx,dy);
      if(d===0) return;
      if(d>TEAR_DIST){ this.active=false; return; }
      const diff=(d-this.rest)/d;
      const ox=dx*0.5*diff, oy=dy*0.5*diff;
      if(!this.a.pinned){ this.a.x+=ox; this.a.y+=oy; }
      if(!this.b.pinned){ this.b.x-=ox; this.b.y-=oy; }
    }
  }

  let points=[], links=[];
  const idx=(x,y)=>y*COLS+x;

  function adaptCloth(){
    const base = Math.min(W,H);
    SPACING = clamp((base/40)|0, 10, 22);

    const hudH = Math.ceil(hud.getBoundingClientRect().height);
    const band = grooveBandRect();
    const usableH = Math.max(160, band.y - (hudH + 14));
    const usableW = W - 24;

    COLS = clamp(((usableW/SPACING)|0)-2, 26, 80);
    ROWS = clamp(((usableH/SPACING)|0)-2, 14, 56);

    TEAR_DIST = SPACING * 2.2;
    FIELD_R = SPACING * 5.0;
    CUT_RADIUS = SPACING * 1.25;
    FIELD_STRENGTH = clamp(SPACING/6, 1.6, 3.4);
  }

  function buildCloth(){
    points=[]; links=[];
    const hudH = Math.ceil(hud.getBoundingClientRect().height);
    const startY = hudH + 12;
    const startX = 12;

    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const px=startX+x*SPACING;
        const py=startY+y*SPACING;
        const pinned = (y===0) && (x%2===0);
        points.push(new Point(px,py,pinned));
      }
    }
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(x<COLS-1) links.push(new Link(points[idx(x,y)], points[idx(x+1,y)], SPACING));
        if(y<ROWS-1) links.push(new Link(points[idx(x,y)], points[idx(x,y+1)], SPACING));
      }
    }
    const diag = Math.hypot(SPACING,SPACING);
    for(let y=0;y<ROWS-1;y++){
      for(let x=0;x<COLS-1;x++){
        links.push(new Link(points[idx(x,y)],   points[idx(x+1,y+1)], diag));
        links.push(new Link(points[idx(x+1,y)], points[idx(x,y+1)],   diag));
      }
    }
  }

  function rebuildCloth(hard=false){
    // hard:true = reset “pulito” (qui non stiamo salvando strappi: ricostruiamo tutto)
    adaptCloth();
    buildCloth();
  }
  rebuildCloth(true);

  // ---------- Pointer / Hybrid write ----------
  const pointer = { x:W/2, y:H/2, down:false, shift:false };
  let eraseMode = false;

  eraseBtn.addEventListener("click", ()=>{
    eraseMode = !eraseMode;
    eraseBtn.textContent = eraseMode ? "ERASE: ON" : "ERASE: OFF";
    eraseBtn.classList.toggle("active", eraseMode);
  });

  function setPointer(e){
    const r=canvas.getBoundingClientRect();
    pointer.x = e.clientX - r.left;
    pointer.y = e.clientY - r.top;
  }

  function cutLinks(x,y,r){
    const rr=r*r;
    for(const l of links){
      if(!l.active) continue;
      const ax=l.a.x, ay=l.a.y, bx=l.b.x, by=l.b.y;
      const vx=bx-ax, vy=by-ay;
      const wx=x-ax, wy=y-ay;
      const c2=vx*vx+vy*vy;
      let t = c2===0 ? 0 : (wx*vx+wy*vy)/c2;
      t = clamp(t,0,1);
      const px=ax+t*vx, py=ay+t*vy;
      const dx=x-px, dy=y-py;
      if(dx*dx+dy*dy<=rr) l.active=false;
    }
  }

  let lastX=0,lastY=0,lastT=0;
  let dragAccent = 0;
  function updateAccent(){
    const now = performance.now();
    const dt = Math.max(8, now - lastT);
    const dx = pointer.x - lastX, dy = pointer.y - lastY;
    const v = Math.hypot(dx,dy) / dt;
    dragAccent = clamp(v * (0.9 + react*2.0), 0, 1);
    lastX = pointer.x; lastY = pointer.y; lastT = now;
  }

  function toggleCellAt(x,y){
    const band = grooveBandRect();
    const inBand = x>=band.x && x<=band.x+band.w && y>=band.y && y<=band.y+band.h;
    if(!inBand) return false;

    const col = clamp(Math.floor(((x - band.x)/band.w) * STEPS), 0, STEPS-1);
    const row = clamp(Math.floor(((y - band.y)/band.h) * TRACKS), 0, TRACKS-1);

    if(eraseMode) pattern[row][col] = 0;
    else pattern[row][col] = pattern[row][col] ? 0 : 1;

    return true;
  }

  function paintGroove(){
    if(!pointer.down || pointer.shift) return;

    const band = grooveBandRect();
    const inBand = pointer.x>=band.x && pointer.x<=band.x+band.w && pointer.y>=band.y && pointer.y<=band.y+band.h;

    if(inBand){
      const col = clamp(Math.floor(((pointer.x - band.x)/band.w) * STEPS), 0, STEPS-1);
      const row = clamp(Math.floor(((pointer.y - band.y)/band.h) * TRACKS), 0, TRACKS-1);
      pattern[row][col] = eraseMode ? 0 : 1;
      return;
    }

    // fuori banda: “gesture grossa”
    const col = clamp(Math.floor((pointer.x / W) * STEPS), 0, STEPS-1);
    const baseRow = clamp(Math.floor((pointer.y / H) * TRACKS), 0, TRACKS-1);

    const stepBrush = 1 + Math.floor(dragAccent * 2); // 1..3
    const trackSpread = dragAccent > 0.55 ? 1 : 0;

    for(let dc=-stepBrush; dc<=stepBrush; dc++){
      const s = (col + dc + STEPS) % STEPS;
      const edge = Math.abs(dc) / (stepBrush || 1);
      const prob = 1 - (0.60 * edge);
      if(Math.random() > prob) continue;

      for(let dr=-trackSpread; dr<=trackSpread; dr++){
        const r = clamp(baseRow + dr, 0, TRACKS-1);

        let bias = 1.0;
        if(r===0) bias=0.55; // kick
        if(r===1) bias=0.65; // clap
        if(r===2) bias=1.00; // shaker
        if(r===3) bias=0.95; // conga
        if(r===4) bias=0.75; // bass
        if(Math.random() > bias) continue;

        pattern[r][s] = eraseMode ? 0 : 1;
      }
    }
  }

  // Pointer events (affidabili iOS)
  canvas.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    setPointer(e);
    pointer.down = true;
    pointer.shift = !!e.shiftKey;
    lastX=pointer.x; lastY=pointer.y; lastT=performance.now();
    dragAccent=0;

    toggleCellAt(pointer.x, pointer.y);
    if(pointer.shift) cutLinks(pointer.x, pointer.y, CUT_RADIUS);

    try{ canvas.setPointerCapture(e.pointerId); }catch{}
  }, {passive:false});

  canvas.addEventListener("pointermove", (e)=>{
    e.preventDefault();
    setPointer(e);
    pointer.shift = !!e.shiftKey;
    if(pointer.down) updateAccent();
    if(pointer.down && pointer.shift) cutLinks(pointer.x, pointer.y, CUT_RADIUS);
  }, {passive:false});

  canvas.addEventListener("pointerup", (e)=>{
    e.preventDefault();
    pointer.down = false;
    dragAccent *= 0.5;
    try{ canvas.releasePointerCapture(e.pointerId); }catch{}
  }, {passive:false});

  // Double tap/click = reset afro + cloth
  let lastTap=0;
  canvas.addEventListener("pointerup", ()=>{
    const now = performance.now();
    if(now-lastTap<320){
      seedAfro();
      rebuildCloth(true);
    }
    lastTap=now;
  }, {passive:true});

  // ---------- Audio + WAV stereo REC ----------
  let audio = null;

  function createAudio(){
    const AC = window.AudioContext || window.webkitAudioContext;
    if(!AC) throw new Error("AudioContext non supportato.");

    const ac = new AC({ latencyHint: "interactive" });
    const master = ac.createGain();
    master.gain.value = 0.42;
    master.connect(ac.destination);

    const noiseBuf = ac.createBuffer(1, ac.sampleRate * 1.0, ac.sampleRate);
    const data = noiseBuf.getChannelData(0);
    for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1);

    function envGain(t, a, d, peak){
      const g = ac.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(peak, t + a);
      g.gain.exponentialRampToValueAtTime(0.0001, t + a + d);
      return g;
    }
    function panNode(p){
      const pn = ac.createStereoPanner();
      pn.pan.value = p;
      return pn;
    }

    function kick(t){
      const o = ac.createOscillator();
      o.type="sine";
      const g = envGain(t,0.003,0.20,1.0);
      o.frequency.setValueAtTime(120,t);
      o.frequency.exponentialRampToValueAtTime(48,t+0.20);
      o.connect(g).connect(panNode(-0.05)).connect(master);
      o.start(t); o.stop(t+0.28);
    }
    function clap(t){
      const src = ac.createBufferSource();
      src.buffer=noiseBuf;
      const bp=ac.createBiquadFilter();
      bp.type="bandpass"; bp.frequency.value=2400; bp.Q.value=0.9;
      const g=envGain(t,0.002,0.11,0.65);
      src.connect(bp).connect(g).connect(panNode(0.15)).connect(master);
      src.start(t); src.stop(t+0.14);
    }
    function shaker(t, accent=1){
      const src=ac.createBufferSource();
      src.buffer=noiseBuf;
      const hp=ac.createBiquadFilter();
      hp.type="highpass"; hp.frequency.value=7200; hp.Q.value=0.8;
      const g=envGain(t,0.001,0.035,0.18*accent);
      src.connect(hp).connect(g).connect(panNode(-0.25)).connect(master);
      src.start(t); src.stop(t+0.06);
    }
    function conga(t, accent=1){
      const o=ac.createOscillator();
      o.type="sine";
      const g=envGain(t,0.002,0.12,0.30*accent);
      o.frequency.setValueAtTime(200,t);
      o.frequency.exponentialRampToValueAtTime(125,t+0.10);
      o.connect(g).connect(panNode(0.28)).connect(master);
      o.start(t); o.stop(t+0.18);
    }
    function bass(t, step){
      const o=ac.createOscillator();
      o.type="triangle";
      const g=envGain(t,0.003,0.26,0.30);
      const notes=[55,55,65.4,73.4,65.4,55,49,55];
      o.frequency.setValueAtTime(notes[step%notes.length], t);
      const lp=ac.createBiquadFilter();
      lp.type="lowpass"; lp.frequency.value=180; lp.Q.value=0.8;
      o.connect(lp).connect(g).connect(panNode(0.02)).connect(master);
      o.start(t); o.stop(t+0.32);
    }

    // REC (stereo)
    const rec = { node:null, bufsL:[], bufsR:[], isRec:false, sampleRate:ac.sampleRate };
    rec.node = ac.createScriptProcessor(4096, 2, 2);
    rec.node.onaudioprocess = (e)=>{
      if(!rec.isRec) return;
      const in0 = e.inputBuffer.getChannelData(0);
      const in1 = (e.inputBuffer.numberOfChannels>1) ? e.inputBuffer.getChannelData(1) : in0;
      rec.bufsL.push(new Float32Array(in0));
      rec.bufsR.push(new Float32Array(in1));
    };

    const sink = ac.createGain(); sink.gain.value = 0.0;
    master.connect(rec.node);
    rec.node.connect(sink);
    sink.connect(ac.destination);

    function encodeWAVStereo(bufsL, bufsR, sampleRate){
      let length=0; for(const b of bufsL) length+=b.length;
      const inter = new Int16Array(length*2);
      let o=0;
      for(let i=0;i<bufsL.length;i++){
        const L=bufsL[i], R=bufsR[i]||L;
        for(let n=0;n<L.length;n++){
          let sL=Math.max(-1,Math.min(1,L[n]));
          let sR=Math.max(-1,Math.min(1,R[n]));
          inter[o++] = (sL<0 ? sL*0x8000 : sL*0x7FFF) | 0;
          inter[o++] = (sR<0 ? sR*0x8000 : sR*0x7FFF) | 0;
        }
      }
      const wav = new ArrayBuffer(44 + inter.length*2);
      const v = new DataView(wav);
      const wstr=(p,s)=>{for(let i=0;i<s.length;i++) v.setUint8(p+i, s.charCodeAt(i));};
      const numCh=2, bits=16;
      const blockAlign = numCh*(bits/8);
      const byteRate = sampleRate*blockAlign;

      wstr(0,"RIFF");
      v.setUint32(4, 36 + inter.length*2, true);
      wstr(8,"WAVE");
      wstr(12,"fmt ");
      v.setUint32(16,16,true);
      v.setUint16(20,1,true);
      v.setUint16(22,numCh,true);
      v.setUint32(24,sampleRate,true);
      v.setUint32(28,byteRate,true);
      v.setUint16(32,blockAlign,true);
      v.setUint16(34,bits,true);
      wstr(36,"data");
      v.setUint32(40, inter.length*2, true);

      let p=44;
      for(let i=0;i<inter.length;i++,p+=2) v.setInt16(p, inter[i], true);
      return new Blob([v], {type:"audio/wav"});
    }

    function startRec(){ rec.bufsL.length=0; rec.bufsR.length=0; rec.isRec=true; }
    function stopRec(){
      rec.isRec=false;
      const blob = encodeWAVStereo(rec.bufsL, rec.bufsR, rec.sampleRate);
      rec.bufsL.length=0; rec.bufsR.length=0;
      return blob;
    }

    // Scheduler
    let step=0, nextTime=0;
    const lookahead=0.10, interval=25;
    let timer=null;

    function schedule(){
      const spb = 60 / bpm;
      const baseStep = spb / 4;
      while(nextTime < ac.currentTime + lookahead){
        const isOff = (step%2)===1;
        const swingOffset = isOff ? (baseStep*(swing-0.5)) : 0;
        const t = nextTime + swingOffset;

        if(pattern[0][step]) kick(t);
        if(pattern[1][step]) clap(t);
        if(pattern[2][step]) shaker(t, 0.85 + 0.85*dragAccent);
        if(pattern[3][step]) conga(t, 0.80 + 0.90*dragAccent);
        if(pattern[4][step]) bass(t, step);

        step = (step+1)%STEPS;
        nextTime += baseStep;
      }
    }

    function start(){
      if(timer) return;
      nextTime = ac.currentTime + 0.05;
      timer = setInterval(schedule, interval);
    }
    function stop(){
      if(timer){ clearInterval(timer); timer=null; }
    }

    return {
      ac, start, stop,
      isRunning: ()=>!!timer,
      startRec, stopRec,
      isRecRunning: ()=>rec.isRec
    };
  }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href=url; a.download=filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
  }

  audioBtn.addEventListener("click", ()=>{
    try{
      logErr("");
      if(!audio){
        audio = createAudio();
        audio.ac.resume().then(()=>{
          audio.start();
          audioBtn.textContent = "■ AUDIO";
        });
        return;
      }
      if(audio.isRunning()){
        audio.stop();
        audioBtn.textContent = "▶ AUDIO";
      }else{
        audio.ac.resume().then(()=>{
          audio.start();
          audioBtn.textContent = "■ AUDIO";
        });
      }
    }catch(err){ logErr(err); }
  });

  recBtn.addEventListener("click", async ()=>{
    try{
      logErr("");
      if(!audio){
        audio = createAudio();
        await audio.ac.resume();
        audio.start();
        audioBtn.textContent = "■ AUDIO";
      }else{
        await audio.ac.resume();
        if(!audio.isRunning()) audio.start();
        audioBtn.textContent = "■ AUDIO";
      }
      if(audio.isRecRunning()) return;

      audio.startRec();
      recBtn.classList.add("active");
      recBtn.textContent = "● REC…";
      stopRecBtn.style.display = "inline-flex";
    }catch(err){
      logErr("REC error: " + err);
    }
  });

  stopRecBtn.addEventListener("click", ()=>{
    try{
      if(!audio || !audio.isRecRunning()) return;
      const wav = audio.stopRec();
      const stamp = new Date().toISOString().replace(/[:.]/g,"-");
      downloadBlob(wav, `afro-groove-stereo-${stamp}.wav`);
      recBtn.classList.remove("active");
      recBtn.textContent = "● REC WAV";
      stopRecBtn.style.display = "none";
    }catch(err){
      logErr("STOP REC error: " + err);
    }
  });

  // ---------- Simulation ----------
  function applyVoidField(){
    if(!pointer.down || pointer.shift) return;
    const cx=pointer.x, cy=pointer.y, R=FIELD_R, R2=R*R;
    for(const p of points){
      if(p.pinned) continue;
      const dx=p.x-cx, dy=p.y-cy;
      const d2=dx*dx+dy*dy;
      if(d2>R2) continue;
      const d=Math.sqrt(d2) || 0.0001;
      const t=1-(d/R);
      const s=(t*t)*FIELD_STRENGTH*(0.9 + react);
      const nx=dx/d, ny=dy/d;
      p.x  += nx*s*6; p.y  += ny*s*6;
      p.px += nx*s*3; p.py += ny*s*3;
    }
  }

  // ---------- Render ----------
  function drawGrooveBand(){
    const band = grooveBandRect();

    ctx.fillStyle = 'rgba(0,0,0,0.32)';
    ctx.fillRect(band.x, band.y, band.w, band.h);

    ctx.strokeStyle = 'rgba(120,255,140,0.16)';
    ctx.lineWidth = 1;

    for(let s=0;s<=STEPS;s++){
      const x = band.x + (s/STEPS)*band.w;
      ctx.beginPath(); ctx.moveTo(x, band.y); ctx.lineTo(x, band.y+band.h); ctx.stroke();
    }
    for(let r=0;r<=TRACKS;r++){
      const y = band.y + (r/TRACKS)*band.h;
      ctx.beginPath(); ctx.moveTo(band.x, y); ctx.lineTo(band.x+band.w, y); ctx.stroke();
    }

    for(let r=0;r<TRACKS;r++){
      for(let s=0;s<STEPS;s++){
        if(!pattern[r][s]) continue;
        const x0 = band.x + (s/STEPS)*band.w;
        const y0 = band.y + (r/TRACKS)*band.h;
        const w = band.w/STEPS, h = band.h/TRACKS;
        ctx.fillStyle = 'rgba(120,255,140,0.28)';
        ctx.fillRect(x0+2, y0+2, w-4, h-4);
      }
    }

    // labels
    ctx.fillStyle = 'rgba(214,255,221,0.75)';
    ctx.font = '12px -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial';
    const labels = ["K","C","S","G","B"];
    for(let r=0;r<TRACKS;r++){
      const y = band.y + (r/TRACKS)*band.h + 14;
      ctx.fillText(labels[r], band.x + 6, y);
    }

    // playhead
    if(audio && audio.isRunning()){
      const t = (performance.now()/1000) * (bpm/60) * 4;
      const ph = Math.floor(t) % STEPS;
      const x = band.x + (ph/STEPS)*band.w;
      ctx.strokeStyle = 'rgba(180,255,200,0.55)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(x, band.y); ctx.lineTo(x, band.y+band.h); ctx.stroke();
    }
  }

  function frame(){
    // trail
    ctx.fillStyle = `rgba(5,8,5,${0.08 + (1-trail)*0.20})`;
    ctx.fillRect(0,0,W,H);

    for(const p of points) p.verlet();
    applyVoidField();
    paintGroove();

    for(let k=0;k<ITER;k++){
      for(const l of links) l.satisfy();
      for(const p of points){
        if(p.pinned) continue;
        p.x = clamp(p.x, 2, W-2);
        p.y = clamp(p.y, 2, H-2);
      }
    }

    ctx.lineCap="round";
    for(const l of links){
      if(!l.active) continue;
      const ax=l.a.x, ay=l.a.y, bx=l.b.x, by=l.b.y;
      const d=Math.hypot(bx-ax, by-ay);
      const t=clamp(d/l.rest,0.7,1.6);
      const w=clamp((2.1-(t-0.7))*1.2, 0.75, 2.4);

      if(glow>0.12){
        ctx.lineWidth = w + glow*2.2;
        ctx.strokeStyle = `rgba(120,255,140,${0.08 + glow*0.10})`;
        ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
      }
      ctx.lineWidth=w;
      ctx.strokeStyle='rgba(120,255,140,0.85)';
      ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
    }

    drawGrooveBand();

    ctx.fillStyle = pointer.shift ? 'rgba(255,180,80,0.9)' : 'rgba(180,255,200,0.9)';
    ctx.beginPath(); ctx.arc(pointer.x, pointer.y, 4, 0, Math.PI*2); ctx.fill();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

})();
</script>
</body>
</html>
