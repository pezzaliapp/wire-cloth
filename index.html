<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wire Cloth + Groove Band</title>
  <style>
    html,body{margin:0;height:100%;background:#050805;overflow:hidden}
    canvas{display:block;width:100vw;height:100vh}
    .hud{
      position:fixed;left:12px;top:12px;
      font:12px/1.35 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;
      color:#b6ffbf;opacity:.92;user-select:none;
      background:rgba(0,0,0,.25);padding:8px 10px;border-radius:10px;
      border:1px solid rgba(182,255,191,.2)
    }
    .hud b{color:#d7ffdd}
    .btn{
      display:inline-block;margin-top:6px;
      padding:6px 10px;border-radius:10px;
      border:1px solid rgba(182,255,191,.25);
      cursor:pointer;
      background:rgba(0,0,0,.25);
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hud" id="hud">
    <b>Wire Cloth + Groove</b><br>
    Hold & drag = crea vuoti + scrivi groove<br>
    Shift = taglia (tear) • Doppio tap/click = reset<br>
    <span class="btn" id="audioBtn">▶ START AUDIO</span>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });
  const hud = document.getElementById('hud');
  const audioBtn = document.getElementById('audioBtn');

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  // ---------- resize ----------
  let W=0,H=0,DPR=1;
  function resize(){
    DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
    W = innerWidth|0; H = innerHeight|0;
    canvas.width = (W*DPR)|0; canvas.height=(H*DPR)|0;
    canvas.style.width=W+'px'; canvas.style.height=H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', ()=>{ resize(); reset(); });
  resize();

  // ---------- cloth params ----------
  let COLS=50, ROWS=28, SPACING=16;
  let GRAV=0.42, FRICTION=0.992;
  let ITER=5;
  let TEAR_DIST=32;
  let FIELD_R=80;          // raggio “vuoto”
  let FIELD_STRENGTH=2.8;  // forza repulsiva
  let CUT_RADIUS=18;

  function adapt(){
    const base = Math.min(W,H);
    SPACING = clamp((base/40)|0, 10, 22);
    COLS = clamp(((W/SPACING)|0)-2, 28, 74);
    ROWS = clamp(((H/SPACING)|0)-8, 18, 54);

    TEAR_DIST = SPACING * 2.2;
    FIELD_R = SPACING * 5.0;
    CUT_RADIUS = SPACING * 1.25;
    FIELD_STRENGTH = clamp(SPACING/6, 1.6, 3.4);
  }

  // ---------- groove params ----------
  const STEPS = 16;
  const TRACKS = 4; // 0 kick, 1 snare, 2 hat, 3 bass
  let bpm = 128;
  const pattern = Array.from({length: TRACKS}, ()=> Array(STEPS).fill(0));
  // seed groove base
  // kick: 0, 4, 8, 12
  [0,4,8,12].forEach(s=>pattern[0][s]=1);
  // snare: 4, 12
  [4,12].forEach(s=>pattern[1][s]=1);
  // hat: offbeat
  [2,6,10,14].forEach(s=>pattern[2][s]=1);
  // bass: semplice
  [0,7,8,15].forEach(s=>pattern[3][s]=1);

  // fascia groove (in basso)
  function grooveBandRect(){
    const h = clamp((H*0.20)|0, 120, 220);
    return { x: 20, y: H - h - 20, w: W - 40, h };
  }

  // ---------- structures ----------
  class Point{
    constructor(x,y,pinned=false){
      this.x=x; this.y=y; this.px=x; this.py=y; this.pinned=pinned;
    }
    verlet(){
      if(this.pinned) return;
      const vx=(this.x-this.px)*FRICTION;
      const vy=(this.y-this.py)*FRICTION;
      this.px=this.x; this.py=this.y;
      this.x += vx;
      this.y += vy + GRAV;
    }
  }
  class Link{
    constructor(a,b,rest){ this.a=a; this.b=b; this.rest=rest; this.active=true; }
    satisfy(){
      if(!this.active) return;
      const ax=this.a.x, ay=this.a.y, bx=this.b.x, by=this.b.y;
      const dx=bx-ax, dy=by-ay;
      const d=Math.hypot(dx,dy);
      if(d===0) return;
      if(d>TEAR_DIST){ this.active=false; return; }
      const diff=(d-this.rest)/d;
      const ox=dx*0.5*diff, oy=dy*0.5*diff;
      if(!this.a.pinned){ this.a.x+=ox; this.a.y+=oy; }
      if(!this.b.pinned){ this.b.x-=ox; this.b.y-=oy; }
    }
  }

  let points=[], links=[];
  const idx=(x,y)=>y*COLS+x;

  function build(){
    points=[]; links=[];
    const startY = (H*0.10)|0;
    const startX = ((W-(COLS-1)*SPACING)/2)|0;

    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const px=startX+x*SPACING;
        const py=startY+y*SPACING;
        const pinned = (y===0) && (x%2===0);
        points.push(new Point(px,py,pinned));
      }
    }

    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(x<COLS-1) links.push(new Link(points[idx(x,y)], points[idx(x+1,y)], SPACING));
        if(y<ROWS-1) links.push(new Link(points[idx(x,y)], points[idx(x,y+1)], SPACING));
      }
    }
    const diag = Math.hypot(SPACING,SPACING);
    for(let y=0;y<ROWS-1;y++){
      for(let x=0;x<COLS-1;x++){
        links.push(new Link(points[idx(x,y)],   points[idx(x+1,y+1)], diag));
        links.push(new Link(points[idx(x+1,y)], points[idx(x,y+1)],   diag));
      }
    }
  }

  function reset(){
    adapt();
    build();
  }
  reset();

  // ---------- pointer ----------
  const pointer = { x:W/2, y:H/2, down:false, shift:false };

  function setPointer(e){
    const r=canvas.getBoundingClientRect();
    if(e.touches && e.touches[0]){
      pointer.x = e.touches[0].clientX - r.left;
      pointer.y = e.touches[0].clientY - r.top;
    } else {
      pointer.x = e.clientX - r.left;
      pointer.y = e.clientY - r.top;
    }
  }

  function cutLinks(x,y,r){
    const rr=r*r;
    for(const l of links){
      if(!l.active) continue;
      const ax=l.a.x, ay=l.a.y, bx=l.b.x, by=l.b.y;
      const vx=bx-ax, vy=by-ay;
      const wx=x-ax, wy=y-ay;
      const c2=vx*vx+vy*vy;
      let t = c2===0 ? 0 : (wx*vx+wy*vy)/c2;
      t = clamp(t,0,1);
      const px=ax+t*vx, py=ay+t*vy;
      const dx=x-px, dy=y-py;
      if(dx*dx+dy*dy<=rr) l.active=false;
    }
  }

  // --- void field (repulsore) ---
  function applyVoidField(){
    if(!pointer.down || pointer.shift) return;
    const cx=pointer.x, cy=pointer.y, R=FIELD_R, R2=R*R;
    for(const p of points){
      if(p.pinned) continue;
      const dx=p.x-cx, dy=p.y-cy;
      const d2=dx*dx+dy*dy;
      if(d2>R2) continue;
      const d=Math.sqrt(d2) || 0.0001;
      const t=1-(d/R);
      const s=(t*t)*FIELD_STRENGTH;
      const nx=dx/d, ny=dy/d;
      p.x  += nx*s*6; p.y  += ny*s*6;
      p.px += nx*s*3; p.py += ny*s*3;
    }
  }

  // ---------- groove “paint” ----------
  function paintGrooveFromPointer(){
    if(!pointer.down || pointer.shift) return;

    const band = grooveBandRect();
    // se sei nella fascia, “pittura” pattern
    if(pointer.x < band.x || pointer.x > band.x+band.w ||
       pointer.y < band.y || pointer.y > band.y+band.h) return;

    const col = clamp(Math.floor(((pointer.x - band.x)/band.w) * STEPS), 0, STEPS-1);
    const row = clamp(Math.floor(((pointer.y - band.y)/band.h) * TRACKS), 0, TRACKS-1);

    // toggle “soft” (evita flicker continuo): set ON mentre trascini
    pattern[row][col] = 1;
  }

  // ---------- Web Audio (mini drum synth) ----------
  let audio = null;

  function createAudio(){
    const AC = window.AudioContext || window.webkitAudioContext;
    const ac = new AC({ latencyHint: "interactive" });
    const master = ac.createGain();
    master.gain.value = 0.35;
    master.connect(ac.destination);

    // noise buffer (per snare/hat)
    const noiseBuf = ac.createBuffer(1, ac.sampleRate * 1.0, ac.sampleRate);
    const data = noiseBuf.getChannelData(0);
    for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1);

    function envGain(t, a, d, peak){
      const g = ac.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(peak, t + a);
      g.gain.exponentialRampToValueAtTime(0.0001, t + a + d);
      return g;
    }

    function kick(t){
      const o = ac.createOscillator();
      o.type = "sine";
      const g = envGain(t, 0.003, 0.18, 1.0);
      o.frequency.setValueAtTime(120, t);
      o.frequency.exponentialRampToValueAtTime(45, t+0.18);
      o.connect(g).connect(master);
      o.start(t); o.stop(t+0.25);
    }

    function snare(t){
      const src = ac.createBufferSource();
      src.buffer = noiseBuf;
      const bp = ac.createBiquadFilter();
      bp.type="bandpass"; bp.frequency.value=1800; bp.Q.value=0.7;
      const g = envGain(t, 0.002, 0.12, 0.8);
      src.connect(bp).connect(g).connect(master);
      src.start(t); src.stop(t+0.18);
    }

    function hat(t){
      const src = ac.createBufferSource();
      src.buffer = noiseBuf;
      const hp = ac.createBiquadFilter();
      hp.type="highpass"; hp.frequency.value=6500; hp.Q.value=0.8;
      const g = envGain(t, 0.001, 0.05, 0.35);
      src.connect(hp).connect(g).connect(master);
      src.start(t); src.stop(t+0.08);
    }

    function bass(t, step){
      const o = ac.createOscillator();
      o.type = "triangle";
      const g = envGain(t, 0.003, 0.22, 0.35);
      // 4 note “scala” semplice
      const notes = [55, 65.4, 73.4, 82.4]; // A1/C2/D2/E2-ish
      o.frequency.setValueAtTime(notes[step % notes.length], t);
      o.connect(g).connect(master);
      o.start(t); o.stop(t+0.28);
    }

    // scheduler (lookahead)
    let step = 0;
    let nextTime = 0;
    const lookahead = 0.10; // sec
    const interval = 25;    // ms
    let timer = null;

    function schedule(){
      const spb = 60 / bpm;
      const stepDur = spb / 4; // 16th
      while(nextTime < ac.currentTime + lookahead){
        if(pattern[0][step]) kick(nextTime);
        if(pattern[1][step]) snare(nextTime);
        if(pattern[2][step]) hat(nextTime);
        if(pattern[3][step]) bass(nextTime, step);

        step = (step + 1) % STEPS;
        nextTime += stepDur;
      }
    }

    function start(){
      if(timer) return;
      nextTime = ac.currentTime + 0.05;
      timer = setInterval(schedule, interval);
    }
    function stop(){
      if(timer){ clearInterval(timer); timer=null; }
    }

    return { ac, start, stop, isRunning: ()=>!!timer };
  }

  audioBtn.addEventListener('click', async ()=>{
    if(!audio){
      audio = createAudio();
      await audio.ac.resume();
      audio.start();
      audioBtn.textContent = "■ STOP AUDIO";
      return;
    }
    if(audio.isRunning()){
      audio.stop();
      audioBtn.textContent = "▶ START AUDIO";
    } else {
      await audio.ac.resume();
      audio.start();
      audioBtn.textContent = "■ STOP AUDIO";
    }
  });

  // ---------- events ----------
  canvas.addEventListener('pointerdown', (e)=>{
    setPointer(e);
    pointer.down=true;
    pointer.shift=!!e.shiftKey;
    if(pointer.shift) cutLinks(pointer.x,pointer.y,CUT_RADIUS);
    canvas.setPointerCapture(e.pointerId);
  });

  canvas.addEventListener('pointermove', (e)=>{
    setPointer(e);
    pointer.shift=!!e.shiftKey;
    if(pointer.down && pointer.shift) cutLinks(pointer.x,pointer.y,CUT_RADIUS);
  });

  canvas.addEventListener('pointerup', (e)=>{
    pointer.down=false;
    try{ canvas.releasePointerCapture(e.pointerId); }catch{}
  });

  // double click/tap reset
  let lastTap=0;
  canvas.addEventListener('pointerup', ()=>{
    const now=performance.now();
    if(now-lastTap<320){
      // clear pattern to zeros + reset cloth
      for(let r=0;r<TRACKS;r++) for(let s=0;s<STEPS;s++) pattern[r][s]=0;
      reset();
    }
    lastTap=now;
  });

  // ---------- render helpers ----------
  function drawGrooveBand(){
    const band = grooveBandRect();

    // background band
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(band.x, band.y, band.w, band.h);

    // grid
    ctx.strokeStyle = 'rgba(120,255,140,0.18)';
    ctx.lineWidth = 1;
    for(let s=0;s<=STEPS;s++){
      const x = band.x + (s/STEPS)*band.w;
      ctx.beginPath(); ctx.moveTo(x, band.y); ctx.lineTo(x, band.y+band.h); ctx.stroke();
    }
    for(let r=0;r<=TRACKS;r++){
      const y = band.y + (r/TRACKS)*band.h;
      ctx.beginPath(); ctx.moveTo(band.x, y); ctx.lineTo(band.x+band.w, y); ctx.stroke();
    }

    // steps on
    for(let r=0;r<TRACKS;r++){
      for(let s=0;s<STEPS;s++){
        if(!pattern[r][s]) continue;
        const x0 = band.x + (s/STEPS)*band.w;
        const y0 = band.y + (r/TRACKS)*band.h;
        const w = band.w/STEPS, h = band.h/TRACKS;
        ctx.fillStyle = 'rgba(120,255,140,0.28)';
        ctx.fillRect(x0+2, y0+2, w-4, h-4);
      }
    }

    // pointer hint
    if(pointer.down && !pointer.shift){
      ctx.strokeStyle = 'rgba(180,255,200,0.9)';
      ctx.lineWidth = 2;
      ctx.strokeRect(band.x, band.y, band.w, band.h);
    }
  }

  // ---------- main loop ----------
  function frame(){
    ctx.fillStyle='#050805';
    ctx.fillRect(0,0,W,H);

    // cloth
    for(const p of points) p.verlet();
    applyVoidField();

    // groove paint (scrivi pattern mentre tieni premuto)
    paintGrooveFromPointer();

    for(let k=0;k<ITER;k++){
      for(const l of links) l.satisfy();
      for(const p of points){
        if(p.pinned) continue;
        p.x = clamp(p.x, 2, W-2);
        p.y = clamp(p.y, 2, H-2);
      }
    }

    // draw links
    ctx.lineCap='round';
    for(const l of links){
      if(!l.active) continue;
      const ax=l.a.x, ay=l.a.y, bx=l.b.x, by=l.b.y;
      const d=Math.hypot(bx-ax, by-ay);
      const t=clamp(d/l.rest,0.7,1.6);
      const w=clamp((2.1-(t-0.7))*1.2, 0.75, 2.4);
      ctx.lineWidth=w;
      ctx.strokeStyle='rgba(120,255,140,0.85)';
      ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
    }

    // groove band UI
    drawGrooveBand();

    // pointer dot
    ctx.fillStyle = pointer.shift ? 'rgba(255,180,80,0.9)' : 'rgba(180,255,200,0.9)';
    ctx.beginPath(); ctx.arc(pointer.x, pointer.y, 4, 0, Math.PI*2); ctx.fill();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
