<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Wire Cloth + Groove — FULL (iPhone safe + REC WAV)</title>
  <style>
    :root{
      --bg:#050805;
      --fg:#b6ffbf;
      --fg2:#d7ffdd;
      --panel:rgba(0,0,0,.34);
      --border:rgba(182,255,191,.18);
      --btn:rgba(0,0,0,.25);
      --btnOn:rgba(56,140,74,.35);
      --btnBorder:rgba(182,255,191,.25);
      --btnBorderOn:rgba(125,255,160,.35);
    }
    html,body{margin:0;height:100%;background:var(--bg);overflow:hidden;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;color:var(--fg)}
    canvas{
      position:fixed;inset:0;width:100vw;height:100vh;display:block;
      touch-action:none; /* iPhone: impedisce gesture browser */
      -webkit-user-select:none; user-select:none;
      -webkit-tap-highlight-color:transparent;
    }

    .hud{
      position:fixed;left:12px;top:12px;
      width:min(760px,calc(100vw - 24px));
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      padding:12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 8px 40px rgba(0,0,0,.35);
      pointer-events:auto;
      z-index: 10;
    }
    .hud.menu-open #hudBody{ display:none; } /* FIX: menu non lascia pannello sotto */

    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .title{font-weight:800;letter-spacing:.2px;display:flex;align-items:center;gap:10px}
    .badge{
      display:inline-flex;align-items:center;gap:8px;
      font-size:12px;opacity:.95;
      padding:6px 10px;border-radius:999px;
      border:1px solid rgba(182,255,191,.25);
      background:rgba(0,0,0,.25);
      white-space:nowrap;
    }
    button{
      background:var(--btn);
      border:1px solid var(--btnBorder);
      color:var(--fg2);
      border-radius:14px;
      padding:10px 12px;
      font-weight:800;
      letter-spacing:.2px;
      cursor:pointer;
      -webkit-appearance:none;
      appearance:none;
    }
    button.on{ background:var(--btnOn); border-color:var(--btnBorderOn); }
    .slider{display:flex;align-items:center;gap:10px;width:100%;margin-top:10px}
    .slider label{min-width:78px;opacity:.95}
    input[type="range"]{flex:1}
    .hint{margin-top:10px;font-size:12px;opacity:.82;line-height:1.35}
    .small{font-size:12px;opacity:.88}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;background:rgba(0,0,0,.25);border:1px solid rgba(182,255,191,.15);padding:2px 6px;border-radius:8px}

    /* Hamburger */
    .menuBtn{
      width:44px;height:44px;display:inline-flex;align-items:center;justify-content:center;
      padding:0;border-radius:14px;
    }
    .hamb{ width:18px;height:12px;position:relative;opacity:.95; }
    .hamb::before,.hamb::after,.hamb span{
      content:"";position:absolute;left:0;right:0;height:2px;background:var(--fg2);border-radius:2px;
    }
    .hamb::before{top:0}
    .hamb span{top:5px}
    .hamb::after{bottom:0}

    .drawer{
      position:fixed;left:12px;top:70px;
      width:min(380px,calc(100vw - 24px));
      background:rgba(0,0,0,.52);
      border:1px solid rgba(182,255,191,.22);
      border-radius:16px;
      padding:12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 12px 60px rgba(0,0,0,.45);
      transform: translateY(-8px);
      opacity:0; pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      z-index: 20;
    }
    .drawer.open{ opacity:1; pointer-events:auto; transform: translateY(0); }
    .drawer h3{margin:0 0 8px 0;font-size:14px;color:var(--fg2)}
    .drawer .opt{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:8px 0;border-top:1px solid rgba(182,255,191,.12)
    }
    .toggle{ display:inline-flex;align-items:center;gap:8px;font-size:12px;opacity:.9; }
    .toggle input{ transform: scale(1.1); }
  </style>
</head>

<body>
  <canvas id="c"></canvas>

  <div class="hud" id="hud">
    <div class="row" style="justify-content:space-between">
      <div class="title">
        <button class="menuBtn" id="menuBtn" aria-label="Menu"><div class="hamb"><span></span></div></button>
        <span>Wire Cloth + Groove</span>
        <span class="badge" id="modeBadge">MODE: …</span>
      </div>
      <div class="badge" id="statusBadge">READY</div>
    </div>

    <div id="hudBody">
      <div class="row" style="margin-top:10px">
        <button id="btnPlay" class="on">PLAY</button>
        <button id="btnRec">REC WAV</button>
        <button id="btnCut" class="on">CUT: ON</button>
        <button id="btnAfro" class="on">AFRO</button>
        <button id="btnPieces" class="on">PIECES</button>
        <button id="btnClear">CLEAR GROOVE</button>
        <button id="btnReset">RESET</button>
      </div>

      <div class="slider">
        <label>BPM <b id="bpmVal">123</b></label>
        <input id="bpm" type="range" min="80" max="150" value="123" step="1">
        <span class="small">Swing <b id="swVal">0.58</b></span>
        <input id="sw" type="range" min="0.45" max="0.65" value="0.58" step="0.01">
      </div>

      <div class="slider">
        <label>Trail <b id="trailVal">0.78</b></label>
        <input id="trail" type="range" min="0.00" max="0.95" value="0.78" step="0.01">
        <span class="small">Glow <b id="glowVal">0.60</b></span>
        <input id="glow" type="range" min="0.00" max="0.95" value="0.60" step="0.01">
      </div>

      <div class="hint">
        <b>iPhone:</b> tap/drag nella band in basso = groove • drag sopra = taglia cloth (se CUT ON)<br>
        <span class="small">Desktop: <span class="kbd">Shift</span> mentre trascini = taglio più ampio • doppio tap = reset.</span>
      </div>
    </div>
  </div>

  <div class="drawer" id="drawer">
    <h3>Menu</h3>

    <div class="opt">
      <div class="toggle"><b>Mobile safe</b><span class="small">(auto su iPhone)</span></div>
      <div class="toggle"><input id="forceMobile" type="checkbox"></div>
    </div>

    <div class="opt">
      <div class="toggle"><b>Cloth react</b><span class="small">vibra coi colpi</span></div>
      <input id="react" type="range" min="0.10" max="0.95" value="0.60" step="0.01" style="width:170px">
    </div>

    <div class="opt">
      <div class="toggle"><b>Pieces amount</b><span class="small">particelle</span></div>
      <input id="piecesAmt" type="range" min="0" max="2600" value="1400" step="50" style="width:170px">
    </div>

    <div class="opt">
      <div class="toggle"><b>Wind</b><span class="small">spinta</span></div>
      <input id="wind" type="range" min="-1.0" max="1.0" value="0.20" step="0.01" style="width:170px">
    </div>

    <div class="opt">
      <div class="toggle"><b>Gravity</b><span class="small">caduta</span></div>
      <input id="grav" type="range" min="300" max="1400" value="980" step="10" style="width:170px">
    </div>

    <div class="opt">
      <div class="toggle"><b>Close</b><span class="small">tap fuori</span></div>
      <button id="closeMenu">OK</button>
    </div>
  </div>

<script>
(() => {
  // ---------- DOM ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true });

  const $ = (id) => document.getElementById(id);

  const hud = $('hud');
  const menuBtn = $('menuBtn');
  const drawer = $('drawer');
  const closeMenu = $('closeMenu');

  const modeBadge = $('modeBadge');
  const statusBadge = $('statusBadge');

  const btnPlay = $('btnPlay');
  const btnRec = $('btnRec');
  const btnCut = $('btnCut');
  const btnAfro = $('btnAfro');
  const btnPieces = $('btnPieces');
  const btnClear = $('btnClear');
  const btnReset = $('btnReset');

  const bpmEl = $('bpm'), bpmVal = $('bpmVal');
  const swEl  = $('sw'),  swVal  = $('swVal');
  const trailEl = $('trail'), trailVal = $('trailVal');
  const glowEl  = $('glow'),  glowVal = $('glowVal');

  const forceMobileEl = $('forceMobile');
  const reactEl = $('react');
  const piecesAmtEl = $('piecesAmt');
  const windEl = $('wind');
  const gravEl = $('grav');

  // ---------- Resize ----------
  let W=0, H=0, DPR=1;
  function resize(){
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height= Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height= H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize, { passive:true });
  resize();

  // ---------- Profile ----------
  let forceMobile = false;
  function isMobileAuto(){
    return matchMedia("(pointer: coarse)").matches && matchMedia("(hover:none)").matches && (Math.min(W,H) < 900);
  }
  function profile(){
    return (forceMobile || isMobileAuto()) ? "mobile" : "desktop";
  }
  let PROFILE = profile();

  // ---------- State ----------
  let BPM = +bpmEl.value;
  let SWING = +swEl.value;
  let TRAIL = +trailEl.value;
  let GLOW  = +glowEl.value;

  let REACT = +reactEl.value;
  let MAX_PIECES = +piecesAmtEl.value;
  let WIND = +windEl.value;
  let GRAV = +gravEl.value;

  let cutting = true;
  let afroOn = true;
  let piecesOn = true;
  let playing = true;

  // ---------- Groove ----------
  const LANES = [
    { key:'K', name:'Kick' },
    { key:'C', name:'Clap' },
    { key:'S', name:'Snare' },
    { key:'G', name:'Conga' },
    { key:'B', name:'Bass' },
  ];
  const STEPS = 16;
  let grid = Array.from({length: LANES.length}, () => Array(STEPS).fill(0));
  let step = 0;
  let playPhase = 0;
  let lastNow = performance.now();

  function bandRect(){
    const bandH = Math.max(170, Math.floor(H * 0.28));
    const y0 = H - bandH;
    return { x0:0, y0, w:W, h:bandH };
  }

  function setAfroPreset(){
    for(let r=0;r<LANES.length;r++) grid[r].fill(0);
    [0,3,7,10,12].forEach(i=>grid[0][i]=1);          // kick
    [4,12].forEach(i=>grid[1][i]=1);                 // clap
    [8].forEach(i=>grid[2][i]=1);                    // snare
    [2,5,6,9,11,14,15].forEach(i=>grid[3][i]=1);     // conga
    [0,6,10,12].forEach(i=>grid[4][i]=1);            // bass
  }
  if(afroOn) setAfroPreset();

  // ---------- Audio (Realtime) ----------
  let AC=null, master=null, NOISE=null;

  function ensureAudio(){
    if(AC) return;
    AC = new (window.AudioContext || window.webkitAudioContext)();
    master = AC.createGain();
    master.gain.value = 0.85;
    master.connect(AC.destination);
  }
  function noiseBuffer(ctx){
    const len = Math.floor(ctx.sampleRate * 0.22);
    const b = ctx.createBuffer(1, len, ctx.sampleRate);
    const d = b.getChannelData(0);
    for(let i=0;i<len;i++) d[i] = (Math.random()*2-1);
    return b;
  }

  function trigKick(ctx,t,vel,out){
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type='sine';
    o.frequency.setValueAtTime(140, t);
    o.frequency.exponentialRampToValueAtTime(48, t+0.09);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.9*vel, t+0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
    o.connect(g); g.connect(out);
    o.start(t); o.stop(t+0.14);
  }
  function trigClap(ctx,t,vel,out){
    if(!NOISE) NOISE = noiseBuffer(ctx);
    const src = ctx.createBufferSource(); src.buffer=NOISE;
    const bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=2200; bp.Q.value=0.8;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.linearRampToValueAtTime(0.6*vel, t+0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
    src.connect(bp); bp.connect(g); g.connect(out);
    src.start(t); src.stop(t+0.18);
  }
  function trigSnare(ctx,t,vel,out){
    if(!NOISE) NOISE = noiseBuffer(ctx);
    const src = ctx.createBufferSource(); src.buffer=NOISE;
    const hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=900;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.linearRampToValueAtTime(0.5*vel, t+0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
    src.connect(hp); hp.connect(g); g.connect(out);
    src.start(t); src.stop(t+0.22);
  }
  function trigConga(ctx,t,vel,out){
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type='triangle';
    o.frequency.setValueAtTime(320, t);
    o.frequency.exponentialRampToValueAtTime(220, t+0.08);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.35*vel, t+0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
    o.connect(g); g.connect(out);
    o.start(t); o.stop(t+0.14);
  }
  function trigBass(ctx,t,vel,out){
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type='sawtooth';
    o.frequency.setValueAtTime(55, t);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.18*vel, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
    o.connect(g); g.connect(out);
    o.start(t); o.stop(t+0.22);
  }

  function playCurrentStepRealtime(t){
    const vel=0.95;
    if(grid[0][step]) trigKick(AC,t,vel,master);
    if(grid[1][step]) trigClap(AC,t,vel*0.9,master);
    if(grid[2][step]) trigSnare(AC,t,vel*0.85,master);
    if(grid[3][step]) trigConga(AC,t,vel*0.7,master);
    if(grid[4][step]) trigBass(AC,t,vel*0.8,master);
  }

  // ---------- REC WAV (Offline render 4 bars) ----------
  function writeString(view, offset, string){
    for(let i=0;i<string.length;i++) view.setUint8(offset+i, string.charCodeAt(i));
  }
  function audioBufferToWav(buffer){
    const numCh = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const bitDepth = 16;
    const samples = buffer.length;

    const blockAlign = numCh * bitDepth/8;
    const byteRate = sampleRate * blockAlign;
    const dataSize = samples * blockAlign;

    const ab = new ArrayBuffer(44 + dataSize);
    const view = new DataView(ab);

    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + dataSize, true);
    writeString(view, 8, 'WAVE');
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, numCh, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bitDepth, true);
    writeString(view, 36, 'data');
    view.setUint32(40, dataSize, true);

    const chans = [];
    for(let c=0;c<numCh;c++) chans.push(buffer.getChannelData(c));

    let offset = 44;
    for(let i=0;i<samples;i++){
      for(let c=0;c<numCh;c++){
        let s = Math.max(-1, Math.min(1, chans[c][i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        offset += 2;
      }
    }
    return new Blob([view], { type:'audio/wav' });
  }

  async function renderWav4Bars(){
    // Offline render non richiede AC attivo, ma usiamo gli stessi parametri/pattern
    const sr = 44100;
    const bars = 4;
    const beatsPerBar = 4;
    const totalBeats = bars * beatsPerBar;
    const secondsPerBeat = 60 / BPM;
    const dur = totalBeats * secondsPerBeat;

    const off = new OfflineAudioContext(2, Math.ceil(sr * dur), sr);
    const out = off.createGain();
    out.gain.value = 0.9;
    out.connect(off.destination);

    // local noise
    const len = Math.floor(sr * 0.25);
    const nbuf = off.createBuffer(1, len, sr);
    const nd = nbuf.getChannelData(0);
    for(let i=0;i<len;i++) nd[i] = (Math.random()*2-1);

    const kick = (t, vel)=>trigKick(off,t,vel,out);
    const clap = (t, vel)=>{
      const src = off.createBufferSource(); src.buffer=nbuf;
      const bp = off.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=2200; bp.Q.value=0.8;
      const g = off.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.linearRampToValueAtTime(0.6*vel, t+0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
      src.connect(bp); bp.connect(g); g.connect(out);
      src.start(t); src.stop(t+0.18);
    };
    const sn = (t, vel)=>{
      const src = off.createBufferSource(); src.buffer=nbuf;
      const hp = off.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=900;
      const g = off.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.linearRampToValueAtTime(0.5*vel, t+0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
      src.connect(hp); hp.connect(g); g.connect(out);
      src.start(t); src.stop(t+0.22);
    };
    const conga = (t, vel)=>trigConga(off,t,vel,out);
    const bass = (t, vel)=>trigBass(off,t,vel,out);

    const totalSteps = bars * STEPS;
    for(let s=0; s<totalSteps; s++){
      const localStep = s % STEPS;
      const beatIndex = (s/4); // 16th = 1/4 beat
      const baseT = beatIndex * secondsPerBeat;

      const odd = (localStep % 2) === 1;
      const swingSec = (SWING - 0.5) * 0.16 * secondsPerBeat;
      const t = baseT + (odd ? swingSec : 0);

      const vel = 0.95;
      if(grid[0][localStep]) kick(t, vel);
      if(grid[1][localStep]) clap(t, vel*0.9);
      if(grid[2][localStep]) sn(t, vel*0.85);
      if(grid[3][localStep]) conga(t, vel*0.7);
      if(grid[4][localStep]) bass(t, vel*0.8);
    }

    const rendered = await off.startRendering();
    const wav = audioBufferToWav(rendered);
    const url = URL.createObjectURL(wav);

    const a = document.createElement('a');
    a.href = url;
    a.download = `wirecloth_${BPM}bpm_4bars.wav`;
    document.body.appendChild(a);
    a.click();
    a.remove();

    setTimeout(()=>URL.revokeObjectURL(url), 15000);
  }

  // ---------- Cloth (Verlet) ----------
  let pts=[], cons=[];
  function makeCloth(){
    pts.length=0; cons.length=0;
    PROFILE = profile();
    const mobile = PROFILE==="mobile";

    const cols = mobile ? 54 : 82;
    const rows = mobile ? 30 : 46;

    const topPad = 110;
    const band = bandRect();
    const usableH = Math.max(180, (band.y0 - topPad) - 20);
    const usableW = Math.max(260, W - 40);
    const x0 = 20;
    const y0 = topPad;

    const dx = usableW / (cols-1);
    const dy = usableH / (rows-1);

    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const px = x0 + x*dx;
        const py = y0 + y*dy;
        const pin = (y===0) && (x%2===0);
        pts.push({x:px,y:py,ox:px,oy:py,pin});
      }
    }

    const idx=(x,y)=>y*cols+x;
    const add=(a,b,rest)=>cons.push({a,b,rest,broken:false});
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        if(x<cols-1) add(idx(x,y), idx(x+1,y), dx);
        if(y<rows-1) add(idx(x,y), idx(x,y+1), dy);
        if(!mobile){
          if(x<cols-1 && y<rows-1) add(idx(x,y), idx(x+1,y+1), Math.hypot(dx,dy));
          if(x>0 && y<rows-1) add(idx(x,y), idx(x-1,y+1), Math.hypot(dx,dy));
        }
      }
    }
  }
  makeCloth();

  function verlet(dt){
    const damp = 0.985;
    const band = bandRect();
    for(const p of pts){
      if(p.pin) continue;
      const vx = (p.x - p.ox) * damp;
      const vy = (p.y - p.oy) * damp;

      p.ox = p.x; p.oy = p.y;

      p.x += vx + (WIND * 40) * dt;
      p.y += vy + (GRAV) * dt*dt;

      if(p.x<0) p.x=0;
      if(p.x>W) p.x=W;
      if(p.y<0) p.y=0;
      if(p.y>band.y0-2) p.y=band.y0-2;
    }

    const iters = (PROFILE==="mobile") ? 5 : 8;
    for(let k=0;k<iters;k++){
      for(const c of cons){
        if(c.broken) continue;
        const p1=pts[c.a], p2=pts[c.b];
        let dx=p2.x-p1.x, dy=p2.y-p1.y;
        const dist=Math.hypot(dx,dy)||1e-6;
        const diff=(dist-c.rest)/dist;
        const stiff=0.86;
        dx*=0.5*stiff*diff;
        dy*=0.5*stiff*diff;
        if(!p1.pin){ p1.x+=dx; p1.y+=dy; }
        if(!p2.pin){ p2.x-=dx; p2.y-=dy; }
      }
    }
  }

  function cutAt(x,y,r,aggressive){
    const r2=r*r;
    for(const c of cons){
      if(c.broken) continue;
      const p1=pts[c.a], p2=pts[c.b];
      const mx=(p1.x+p2.x)*0.5;
      const my=(p1.y+p2.y)*0.5;
      const dx=mx-x, dy=my-y;
      const d2=dx*dx+dy*dy;
      if(d2<r2 || (aggressive && d2<r2*1.7)) c.broken=true;
    }
  }

  function clothReact(hitAmount){
    const band = bandRect();
    const centerY = band.y0 - 80;
    const amt = Math.min(1.5, hitAmount) * REACT;
    for(let i=0;i<pts.length;i+=7){
      const p=pts[i];
      if(p.pin) continue;
      const w = Math.max(0, 1 - Math.abs(p.y-centerY)/(band.y0));
      p.y -= (amt*10)*w;
      p.x += (Math.random()*2-1) * (amt*2) * w;
    }
  }

  // ---------- Pieces ----------
  let pieces=[];
  function spawnPieces(n){
    const band=bandRect();
    for(let i=0;i<n;i++){
      pieces.push({
        x: Math.random()*W,
        y: Math.random()*(band.y0-10),
        vx:(Math.random()*2-1)*20,
        vy: 30 + Math.random()*80,
        sz: 1 + Math.random()*2.5,
        a: 0.12 + Math.random()*0.35
      });
    }
  }
  function updatePieces(dt){
    if(!piecesOn) return;
    const mobile = profile()==="mobile";
    const target = Math.max(0, Math.min(MAX_PIECES, mobile ? 1100 : 2600));

    if(pieces.length < target) spawnPieces(Math.min(90, target - pieces.length));
    else if(pieces.length > target) pieces.length = target;

    const band=bandRect();
    const limitY = band.y0 - 6;

    for(const p of pieces){
      p.vx += (WIND*18) * dt;
      p.vy += (GRAV*0.06) * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;

      if(p.x < -10) p.x = W+10;
      if(p.x > W+10) p.x = -10;
      if(p.y > limitY){
        p.y = -5;
        p.x = Math.random()*W;
        p.vy = 30 + Math.random()*90;
      }
    }
  }
  function drawPieces(){
    if(!piecesOn) return;
    const band = bandRect();
    ctx.save();
    for(const p of pieces){
      if(p.y >= band.y0) continue;
      ctx.globalAlpha = p.a;
      ctx.fillStyle = '#b6ffbf';
      ctx.fillRect(p.x, p.y, p.sz, p.sz);
    }
    ctx.restore();
  }

  // ---------- Draw band + cloth ----------
  function drawBand(){
    const band=bandRect();
    const x0=band.x0, y0=band.y0, w=band.w, h=band.h;

    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = '#050805';
    ctx.fillRect(x0,y0,w,h);

    ctx.globalAlpha = 0.34;
    ctx.strokeStyle = '#2b6a34';
    ctx.lineWidth = 1;

    const colW = w / STEPS;
    const laneH = h / LANES.length;

    for(let i=0;i<=STEPS;i++){
      ctx.beginPath();
      ctx.moveTo(x0 + i*colW, y0);
      ctx.lineTo(x0 + i*colW, y0 + h);
      ctx.stroke();
    }
    for(let r=0;r<=LANES.length;r++){
      ctx.beginPath();
      ctx.moveTo(x0, y0 + r*laneH);
      ctx.lineTo(x0 + w, y0 + r*laneH);
      ctx.stroke();
    }

    ctx.globalAlpha = 0.85;
    ctx.fillStyle = '#b6ffbf';
    ctx.font = '12px -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial';
    for(let r=0;r<LANES.length;r++){
      ctx.fillText(LANES[r].key, 10, y0 + (r+0.72)*laneH);
    }

    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#2f8a3c';
    for(let r=0;r<LANES.length;r++){
      for(let c=0;c<STEPS;c++){
        if(!grid[r][c]) continue;
        const px = x0 + c*colW + 2;
        const py = y0 + r*laneH + 2;
        ctx.fillRect(px, py, colW-4, laneH-4);
      }
    }

    ctx.globalAlpha = 0.92;
    ctx.strokeStyle = '#b6ffbf';
    ctx.lineWidth = 2;
    const phx = x0 + (playPhase * w);
    ctx.beginPath();
    ctx.moveTo(phx, y0);
    ctx.lineTo(phx, y0 + h);
    ctx.stroke();

    ctx.restore();
  }

  function drawCloth(){
    const band = bandRect();
    const intensity = 0.35 + GLOW*0.55;
    ctx.save();
    ctx.globalAlpha = intensity;
    ctx.strokeStyle = '#76ff93';
    ctx.lineWidth = 1;

    ctx.beginPath();
    for(const c of cons){
      if(c.broken) continue;
      const p1=pts[c.a], p2=pts[c.b];
      if(p1.y >= band.y0 || p2.y >= band.y0) continue;
      ctx.moveTo(p1.x,p1.y);
      ctx.lineTo(p2.x,p2.y);
    }
    ctx.stroke();
    ctx.restore();
  }

  // ---------- Input (Pointer Events iPhone-safe) ----------
  function normXY(e){
    const r = canvas.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  function toggleCellAt(x,y){
    const band=bandRect();
    if(y < band.y0) return false;
    const laneH = band.h / LANES.length;
    const colW = band.w / STEPS;
    const lane = Math.floor((y - band.y0) / laneH);
    const st = Math.floor(x / colW);
    if(lane<0 || lane>=LANES.length || st<0 || st>=STEPS) return false;
    grid[lane][st] = grid[lane][st] ? 0 : 1;
    return true;
  }

  function paintCellAt(x,y){
    const band=bandRect();
    const laneH = band.h / LANES.length;
    const colW = band.w / STEPS;

    let st = Math.max(0, Math.min(STEPS-1, Math.floor(x / colW)));
    let lane;
    if(y >= band.y0){
      lane = Math.max(0, Math.min(LANES.length-1, Math.floor((y - band.y0)/laneH)));
    }else{
      lane = 3; // conga default
    }
    grid[lane][st] = 1;
  }

  const pointers = new Map();
  let lastTap = 0;

  canvas.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    canvas.setPointerCapture(e.pointerId);
    const p = normXY(e);
    pointers.set(e.pointerId, {x:p.x,y:p.y,down:true,shift:!!e.shiftKey});

    const now = performance.now();
    if(now - lastTap < 260){
      makeCloth();
      pieces.length = 0;
      lastTap = 0;
      statusBadge.textContent = "RESET";
      return;
    }
    lastTap = now;
  }, {passive:false});

  canvas.addEventListener('pointermove', (e)=>{
    e.preventDefault();
    const s = pointers.get(e.pointerId);
    if(!s || !s.down) return;
    const p = normXY(e);
    s.x = p.x; s.y = p.y;

    const band = bandRect();
    const aggressive = (!!e.shiftKey) || s.shift;

    paintCellAt(p.x,p.y);

    if(cutting && p.y < band.y0){
      const r = (profile()==="mobile") ? 18 : 14;
      cutAt(p.x,p.y, r, aggressive);
    }
  }, {passive:false});

  canvas.addEventListener('pointerup', (e)=>{
    e.preventDefault();
    const s = pointers.get(e.pointerId);
    if(!s) return;
    const p = normXY(e);

    const band = bandRect();
    if(p.y >= band.y0){
      toggleCellAt(p.x,p.y);
    }else{
      if(cutting){
        const r = (profile()==="mobile") ? 14 : 11;
        cutAt(p.x,p.y, r, false);
      }else{
        paintCellAt(p.x,p.y);
      }
    }
    pointers.delete(e.pointerId);
  }, {passive:false});

  canvas.addEventListener('pointercancel', (e)=>{
    e.preventDefault();
    pointers.delete(e.pointerId);
  }, {passive:false});

  // ---------- Transport + Render ----------
  function transport(now){
    const dtMs = now - lastNow;
    lastNow = now;
    const dt = Math.min(0.033, dtMs/1000);

    PROFILE = profile();
    updatePieces(dt);

    if(!playing) return;

    const beatMs = (60_000 / BPM);
    const stepMs = beatMs / 4;
    playPhase += dtMs / (stepMs * STEPS);
    while(playPhase >= 1) playPhase -= 1;

    const targetStep = Math.floor(playPhase * STEPS) % STEPS;
    if(targetStep !== step){
      step = targetStep;

      if(AC){
        const odd = (step % 2) === 1;
        const swingSec = (SWING - 0.5) * 0.16 * (60 / BPM);
        const t = AC.currentTime + (odd ? swingSec : 0);
        playCurrentStepRealtime(t);
      }

      let hits=0;
      for(let r=0;r<LANES.length;r++) hits += grid[r][step] ? 1 : 0;
      if(hits) clothReact(hits*0.35);
    }
  }

  function frame(now){
    if(TRAIL <= 0){
      ctx.fillStyle = '#050805';
      ctx.fillRect(0,0,W,H);
    }else{
      const a = Math.max(0.03, 1 - TRAIL);
      ctx.save();
      ctx.globalAlpha = a;
      ctx.fillStyle = '#050805';
      ctx.fillRect(0,0,W,H);
      ctx.restore();
    }

    transport(now);

    verlet(1/60);

    drawPieces();
    drawCloth();
    drawBand();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // ---------- UI ----------
  function syncUI(){
    bpmVal.textContent = BPM.toString();
    swVal.textContent  = SWING.toFixed(2);
    trailVal.textContent = TRAIL.toFixed(2);
    glowVal.textContent  = GLOW.toFixed(2);

    btnPlay.classList.toggle('on', playing);
    btnPlay.textContent = playing ? "PLAY" : "PAUSE";

    btnCut.classList.toggle('on', cutting);
    btnCut.textContent = cutting ? "CUT: ON" : "CUT: OFF";

    btnAfro.classList.toggle('on', afroOn);
    btnPieces.classList.toggle('on', piecesOn);

    forceMobileEl.checked = forceMobile;
    modeBadge.textContent = `MODE: ${profile().toUpperCase()} • DPR ${DPR.toFixed(2)}`;
  }
  syncUI();
  statusBadge.textContent = "PLAYING";

  bpmEl.addEventListener('input', ()=>{ BPM=+bpmEl.value; syncUI(); }, {passive:true});
  swEl.addEventListener('input',  ()=>{ SWING=+swEl.value; syncUI(); }, {passive:true});
  trailEl.addEventListener('input',()=>{ TRAIL=+trailEl.value; syncUI(); }, {passive:true});
  glowEl.addEventListener('input', ()=>{ GLOW=+glowEl.value; syncUI(); }, {passive:true});

  reactEl.addEventListener('input', ()=>{ REACT=+reactEl.value; }, {passive:true});
  piecesAmtEl.addEventListener('input', ()=>{ MAX_PIECES=+piecesAmtEl.value; }, {passive:true});
  windEl.addEventListener('input', ()=>{ WIND=+windEl.value; }, {passive:true});
  gravEl.addEventListener('input', ()=>{ GRAV=+gravEl.value; }, {passive:true});

  btnCut.addEventListener('click', ()=>{ cutting=!cutting; syncUI(); }, {passive:true});
  btnPieces.addEventListener('click', ()=>{ piecesOn=!piecesOn; syncUI(); }, {passive:true});

  btnAfro.addEventListener('click', ()=>{
    afroOn = !afroOn;
    if(afroOn) setAfroPreset();
    syncUI();
  }, {passive:true});

  btnClear.addEventListener('click', ()=>{
    for(let r=0;r<LANES.length;r++) grid[r].fill(0);
  }, {passive:true});

  btnReset.addEventListener('click', ()=>{
    makeCloth();
    pieces.length = 0;
    statusBadge.textContent = "RESET";
  }, {passive:true});

  btnPlay.addEventListener('click', async ()=>{
    ensureAudio();
    if(AC.state === 'suspended') await AC.resume(); // iOS requirement
    playing = !playing;
    statusBadge.textContent = playing ? "PLAYING" : "PAUSED";
    syncUI();
  }, {passive:true});

  btnRec.addEventListener('click', async ()=>{
    try{
      statusBadge.textContent = "RENDERING…";
      await renderWav4Bars();
      statusBadge.textContent = "WAV READY";
      setTimeout(()=>statusBadge.textContent = playing ? "PLAYING" : "PAUSED", 1200);
    }catch(err){
      console.error(err);
      statusBadge.textContent = "REC ERROR";
      alert("REC WAV non disponibile qui. Serve HTTPS e browser compatibile.");
    }
  }, {passive:true});

  // ---------- Menu open/close (FIX: nasconde hudBody) ----------
  function openMenu(){
    drawer.classList.add('open');
    hud.classList.add('menu-open');
  }
  function closeMenuFn(){
    drawer.classList.remove('open');
    hud.classList.remove('menu-open');
  }

  menuBtn.addEventListener('click', ()=>{
    if(drawer.classList.contains('open')) closeMenuFn();
    else openMenu();
  }, {passive:true});

  closeMenu.addEventListener('click', closeMenuFn, {passive:true});

  document.addEventListener('pointerdown', (e)=>{
    if(!drawer.classList.contains('open')) return;
    const inDrawer = drawer.contains(e.target);
    const inBtn = menuBtn.contains(e.target);
    if(!inDrawer && !inBtn) closeMenuFn();
  }, {passive:true});

  forceMobileEl.addEventListener('change', ()=>{
    forceMobile = !!forceMobileEl.checked;
    makeCloth();
    if(profile()==="mobile"){
      // safety: limita pezzi su mobile se alto
      const v = Math.min(+piecesAmtEl.value, 1100);
      if(+piecesAmtEl.value !== v){
        piecesAmtEl.value = String(v);
        MAX_PIECES = v;
      }
    }
    syncUI();
  }, {passive:true});

})();
</script>
</body>
</html>
