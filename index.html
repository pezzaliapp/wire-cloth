<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>Wire Cloth + Groove — Universal (One-File)</title>
  <style>
    :root{
      --bg:#050805;
      --fg:#b6ffbf;
      --fg2:#d7ffdd;
      --line:rgba(120,255,140,.85);
      --lineSoft:rgba(120,255,140,.22);
      --panel:rgba(0,0,0,.34);
      --panel2:rgba(0,0,0,.55);
      --border:rgba(182,255,191,.22);
      --shadow:rgba(0,0,0,.35);
      --danger:rgba(255,120,120,.35);
    }
    html,body{margin:0;height:100%;background:var(--bg);overflow:hidden}
    canvas{
      display:block;width:100vw;height:100vh;
      touch-action:none;
      -webkit-tap-highlight-color:transparent;
      user-select:none;
    }

    /* HUD */
    .hud{
      position:fixed;left:12px;top:12px;z-index:20;
      font:12px/1.35 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;
      color:var(--fg);
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      padding:10px 12px;
      max-width:min(720px, calc(100vw - 24px));
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 12px 35px var(--shadow);
    }
    .titleRow{
      display:flex;align-items:center;gap:10px;
      margin-bottom:6px;
    }
    .title{
      font-weight:700;color:var(--fg2);
      letter-spacing:.2px;
      font-size:13px;
    }
    .pill{
      padding:4px 8px;border-radius:999px;
      border:1px solid rgba(182,255,191,.18);
      background:rgba(0,0,0,.22);
      font-size:11px;opacity:.9
    }
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px}
    .sp{flex:1}

    .btn{
      display:inline-flex;align-items:center;justify-content:center;
      padding:9px 12px;border-radius:12px;
      border:1px solid rgba(182,255,191,.25);
      background:rgba(0,0,0,.22);
      color:var(--fg2);
      cursor:pointer;
      min-height:38px;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
    }
    .btn.small{padding:7px 10px;min-height:34px;font-size:12px;opacity:.95}
    .btn.active{background:rgba(120,255,140,.22)}
    .btn.danger{border-color:var(--danger)}
    .btn.danger.active{background:rgba(255,120,120,.20)}
    .btn.ghost{opacity:.85}
    .btn.icon{
      width:38px;min-width:38px;padding:0;border-radius:12px;
      font-size:16px;line-height:1;
    }

    .kv{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    .kv .k{opacity:.9}
    .kv .v{color:var(--fg2);font-weight:700}

    input[type="range"]{
      width:170px;
      -webkit-appearance:none;appearance:none;
      height:6px;border-radius:999px;
      background:rgba(182,255,191,.25);
      outline:none;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;appearance:none;
      width:20px;height:20px;border-radius:50%;
      background:var(--fg2);
      border:1px solid rgba(0,0,0,.45);
    }

    .hint{margin-top:6px;opacity:.85}
    .err{margin-top:8px;color:#ffd2d2;white-space:pre-wrap}

    /* Modal Menu */
    .overlay{
      position:fixed;inset:0;z-index:50;
      background:rgba(0,0,0,.45);
      display:none;
      backdrop-filter: blur(3px);
      -webkit-backdrop-filter: blur(3px);
    }
    .overlay.show{display:block}
    .panel{
      position:absolute;left:12px;top:12px;
      width:min(420px, calc(100vw - 24px));
      background:var(--panel2);
      border:1px solid rgba(182,255,191,.20);
      border-radius:16px;
      padding:12px;
      box-shadow: 0 18px 55px rgba(0,0,0,.55);
    }
    .panel h3{
      margin:0 0 10px 0;
      font-size:13px;color:var(--fg2);
      letter-spacing:.2px;
    }
    .grid2{display:grid;grid-template-columns: 1fr 1fr;gap:10px}
    .item{
      border:1px solid rgba(182,255,191,.16);
      background:rgba(0,0,0,.18);
      border-radius:12px;
      padding:10px;
    }
    .item .lbl{opacity:.9;margin-bottom:8px}
    .item .sub{opacity:.75;font-size:11px;margin-top:6px}
    .tog{
      display:flex;align-items:center;gap:8px;justify-content:space-between
    }
    .tog input{transform:scale(1.1)}
    .panel .footer{
      display:flex;gap:8px;align-items:center;margin-top:10px
    }

    /* Mobile tweaks */
    @media (max-width:480px){
      .hud{left:10px;top:10px;padding:10px 10px;font-size:12px}
      input[type="range"]{width:140px}
      .btn{padding:9px 10px}
      .pill{display:none}
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div class="hud" id="hud">
  <div class="titleRow">
    <span class="btn icon" id="menuBtn" title="Menu">☰</span>
    <div class="title">Wire Cloth + Groove</div>
    <div class="pill" id="modePill">MODE</div>
    <div class="sp"></div>
    <div class="pill" id="statePill">READY</div>
  </div>

  <div class="row">
    <span class="btn" id="audioBtn">▶ START AUDIO</span>
    <span class="btn small" id="cutBtn">CUT: OFF</span>
    <span class="btn small" id="eraseBtn">ERASE: OFF</span>
    <span class="btn small danger" id="recBtn">● REC</span>
    <span class="btn small danger" id="stopRecBtn" style="display:none">■ STOP</span>
    <span class="btn small ghost" id="rec4Btn" title="Registra 4 battute (loop pulito)">REC 4 BARS</span>
  </div>

  <div class="row kv">
    <span class="k">BPM</span><span class="v" id="bpmOut">110</span>
    <input id="bpm" type="range" min="90" max="140" step="1" value="110"/>
    <span class="k">Swing</span><span class="v" id="swOut">0.58</span>
    <input id="sw" type="range" min="0.50" max="0.64" step="0.01" value="0.58"/>
  </div>

  <div class="row">
    <span class="btn small" id="afroBtn">AFRO</span>
    <span class="btn small" id="clearBtn">CLEAR</span>
    <span class="btn small" id="resetBtn">RESET</span>
    <span class="sp"></span>
    <span class="pill" id="recPill" style="display:none">REC 00:00</span>
  </div>

  <div class="hint" id="hint">
    Tip iPhone: prima START AUDIO (gesture), poi REC.
  </div>
  <div class="err" id="err"></div>
</div>

<div class="overlay" id="overlay">
  <div class="panel" id="panel">
    <h3>Menu</h3>

    <div class="grid2">
      <div class="item">
        <div class="tog">
          <div class="lbl">Mobile safe</div>
          <input type="checkbox" id="mobileSafe"/>
        </div>
        <div class="sub">Riduce carico su iPhone/Android (DPR/iter/particles).</div>
      </div>

      <div class="item">
        <div class="lbl">Particles (pezzi)</div>
        <input type="range" id="pieces" min="0" max="250" step="1" value="140"/>
        <div class="sub"><span id="piecesOut">140</span> max</div>
      </div>

      <div class="item">
        <div class="lbl">Cloth react</div>
        <input type="range" id="react" min="0" max="100" step="1" value="55"/>
        <div class="sub"><span id="reactOut">55</span></div>
      </div>

      <div class="item">
        <div class="lbl">Gravity</div>
        <input type="range" id="grav" min="10" max="120" step="1" value="42"/>
        <div class="sub"><span id="gravOut">0.42</span></div>
      </div>

      <div class="item">
        <div class="lbl">Wind</div>
        <input type="range" id="wind" min="-80" max="80" step="1" value="0"/>
        <div class="sub"><span id="windOut">0.00</span></div>
      </div>

      <div class="item">
        <div class="lbl">Trail</div>
        <input type="range" id="trail" min="0" max="95" step="1" value="70"/>
        <div class="sub"><span id="trailOut">0.70</span></div>
      </div>

      <div class="item">
        <div class="lbl">Glow</div>
        <input type="range" id="glow" min="0" max="100" step="1" value="55"/>
        <div class="sub"><span id="glowOut">0.55</span></div>
      </div>

      <div class="item">
        <div class="lbl">Cut radius</div>
        <input type="range" id="cutr" min="8" max="40" step="1" value="18"/>
        <div class="sub"><span id="cutrOut">18</span> px</div>
      </div>
    </div>

    <div class="footer">
      <span class="btn small" id="closeMenuBtn">OK</span>
      <span class="btn small ghost" id="helpBtn">Help</span>
      <span class="sp"></span>
      <span class="btn small ghost" id="panicBtn">RESET ALL</span>
    </div>
  </div>
</div>

<script>
(() => {
  // ---------- DOM ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });

  const hud = document.getElementById('hud');
  const errBox = document.getElementById('err');
  const hint = document.getElementById('hint');

  const menuBtn = document.getElementById('menuBtn');
  const overlay = document.getElementById('overlay');
  const panel = document.getElementById('panel');
  const closeMenuBtn = document.getElementById('closeMenuBtn');
  const helpBtn = document.getElementById('helpBtn');
  const panicBtn = document.getElementById('panicBtn');

  const modePill = document.getElementById('modePill');
  const statePill = document.getElementById('statePill');

  const audioBtn = document.getElementById('audioBtn');
  const cutBtn = document.getElementById('cutBtn');
  const eraseBtn = document.getElementById('eraseBtn');
  const recBtn = document.getElementById('recBtn');
  const stopRecBtn = document.getElementById('stopRecBtn');
  const rec4Btn = document.getElementById('rec4Btn');
  const recPill = document.getElementById('recPill');

  const bpmSlider = document.getElementById('bpm');
  const bpmOut = document.getElementById('bpmOut');
  const swSlider = document.getElementById('sw');
  const swOut = document.getElementById('swOut');

  const afroBtn = document.getElementById('afroBtn');
  const clearBtn = document.getElementById('clearBtn');
  const resetBtn = document.getElementById('resetBtn');

  // menu sliders
  const mobileSafeEl = document.getElementById('mobileSafe');
  const piecesEl = document.getElementById('pieces');
  const reactEl  = document.getElementById('react');
  const gravEl   = document.getElementById('grav');
  const windEl   = document.getElementById('wind');
  const trailEl  = document.getElementById('trail');
  const glowEl   = document.getElementById('glow');
  const cutrEl   = document.getElementById('cutr');

  const piecesOut = document.getElementById('piecesOut');
  const reactOut  = document.getElementById('reactOut');
  const gravOut   = document.getElementById('gravOut');
  const windOut   = document.getElementById('windOut');
  const trailOut  = document.getElementById('trailOut');
  const glowOut   = document.getElementById('glowOut');
  const cutrOut   = document.getElementById('cutrOut');

  // ---------- utils ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
  const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

  function logErr(m){ errBox.textContent = m ? String(m) : ""; }
  function setStatePill(t){ statePill.textContent = t; }
  function fmt2(n){ return (Math.round(n*100)/100).toFixed(2); }

  // prevent HUD/menu from drawing on canvas
  ["pointerdown","pointermove","pointerup","click","touchstart","touchmove","touchend","wheel"].forEach(ev=>{
    hud.addEventListener(ev, e=>{ e.stopPropagation(); }, {passive:false});
    panel.addEventListener(ev, e=>{ e.stopPropagation(); }, {passive:false});
  });

  // ---------- responsive canvas ----------
  let W=0,H=0,DPR=1;
  function resize(){
    const d = devicePixelRatio || 1;
    const dprCap = state.mobileSafe ? 1.5 : 2.0;
    DPR = Math.max(1, Math.min(dprCap, d));
    W = innerWidth|0; H = innerHeight|0;
    canvas.width  = (W*DPR)|0;
    canvas.height = (H*DPR)|0;
    canvas.style.width = W+'px';
    canvas.style.height = H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', ()=>{ resize(); rebuildCloth(); });
  addEventListener('orientationchange', ()=>{ setTimeout(()=>{ resize(); rebuildCloth(); }, 200); });

  // ---------- app state ----------
  const state = {
    bpm: 110,
    swing: 0.58,
    erase: false,
    cut: false,
    mobileSafe: isMobile, // auto ON on mobile
    // visuals/physics
    react: 55,
    grav: 0.42,
    wind: 0.00,
    trail: 0.70,
    glow: 0.55,
    cutRadius: 18,
    piecesMax: 140,
  };

  mobileSafeEl.checked = state.mobileSafe;

  modePill.textContent = isMobile ? "MODE: MOBILE" : "MODE: DESKTOP";
  hint.textContent = isIOS ? "Tip iPhone: prima START AUDIO (gesture), poi REC." : "Drag = sposti/crei vuoti • Band in basso = groove • CUT = strappi • ERASE = cancella groove";

  // ---------- Groove pattern ----------
  const STEPS = 16;
  const TRACKS = 5; // K C S G B
  const pattern = Array.from({length:TRACKS}, ()=>Array(STEPS).fill(0));

  function seedAfro(){
    for(let r=0;r<TRACKS;r++) pattern[r].fill(0);
    [0,3,7,8,11,14].forEach(s => pattern[0][s]=1);     // kick
    [4,12,15].forEach(s => pattern[1][s]=1);           // clap
    [1,2,3,5,6,7,9,10,11,13,14,15].forEach(s=>pattern[2][s]=1); // shaker
    [2,6,10,13].forEach(s => pattern[3][s]=1);         // conga
    [0,7,10,15].forEach(s => pattern[4][s]=1);         // bass
  }
  seedAfro();

  function grooveBandRect(){
    const h = clamp((H*0.22)|0, 120, 220);
    return { x: 16, y: H - h - 16, w: W - 32, h };
  }

  // ---------- Cloth (Verlet + links) ----------
  let COLS=56, ROWS=30, SPACING=16;
  let ITER=6, TEAR_DIST=32;

  class Point{
    constructor(x,y,pinned=false){
      this.x=x; this.y=y; this.px=x; this.py=y;
      this.pinned=pinned;
    }
    verlet(){
      if(this.pinned) return;
      const vx=(this.x-this.px)*0.992;
      const vy=(this.y-this.py)*0.992;
      this.px=this.x; this.py=this.y;
      this.x += vx + state.wind;
      this.y += vy + state.grav;
    }
  }
  class Link{
    constructor(a,b,rest){
      this.a=a; this.b=b; this.rest=rest;
      this.active=true;
    }
    satisfy(){
      if(!this.active) return;
      const ax=this.a.x, ay=this.a.y, bx=this.b.x, by=this.b.y;
      const dx=bx-ax, dy=by-ay;
      const d=Math.hypot(dx,dy);
      if(d===0) return;
      if(d>TEAR_DIST){
        this.active=false;
        spawnTearBits(ax,ay,bx,by);
        return;
      }
      const diff=(d-this.rest)/d;
      const ox=dx*0.5*diff, oy=dy*0.5*diff;
      if(!this.a.pinned){ this.a.x+=ox; this.a.y+=oy; }
      if(!this.b.pinned){ this.b.x-=ox; this.b.y-=oy; }
    }
  }

  let points=[], links=[];
  const idx=(x,y)=>y*COLS+x;

  function adaptGrid(){
    const base = Math.min(W,H);
    SPACING = clamp((base/40)|0, 10, 22);

    const hudH = Math.ceil(hud.getBoundingClientRect().height);
    const band = grooveBandRect();
    const usableH = Math.max(200, band.y - (hudH + 18));
    const usableW = W - 24;

    COLS = clamp(((usableW/SPACING)|0)-2, 26, state.mobileSafe? 62 : 78);
    ROWS = clamp(((usableH/SPACING)|0)-2, 16, state.mobileSafe? 44 : 56);

    TEAR_DIST = SPACING * 2.2;
    ITER = state.mobileSafe ? 5 : 6;
    state.cutRadius = clamp(state.cutRadius, 8, 60);
  }

  function rebuildCloth(){
    adaptGrid();
    points=[]; links=[];
    const hudH = Math.ceil(hud.getBoundingClientRect().height);
    const startX = 12;
    const startY = hudH + 18;

    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const px=startX+x*SPACING;
        const py=startY+y*SPACING;
        const pinned = (y===0) && (x%2===0);
        points.push(new Point(px,py,pinned));
      }
    }

    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(x<COLS-1) links.push(new Link(points[idx(x,y)], points[idx(x+1,y)], SPACING));
        if(y<ROWS-1) links.push(new Link(points[idx(x,y)], points[idx(x,y+1)], SPACING));
      }
    }
    const diag=Math.hypot(SPACING,SPACING);
    for(let y=0;y<ROWS-1;y++){
      for(let x=0;x<COLS-1;x++){
        links.push(new Link(points[idx(x,y)],   points[idx(x+1,y+1)], diag));
        links.push(new Link(points[idx(x+1,y)], points[idx(x,y+1)],   diag));
      }
    }
  }

  // ---------- particles (pieces) ----------
  const bits = [];
  function spawnTearBits(ax,ay,bx,by){
    const max = state.piecesMax;
    if(max<=0) return;
    const n = state.mobileSafe ? 2 : 3;
    for(let i=0;i<n;i++){
      if(bits.length > max) bits.shift();
      const x = ax + (bx-ax)*Math.random();
      const y = ay + (by-ay)*Math.random();
      const ang = (Math.random()*Math.PI*2);
      const sp  = 0.6 + Math.random()*1.6;
      bits.push({
        x, y,
        vx: Math.cos(ang)*sp + state.wind*0.6,
        vy: Math.sin(ang)*sp - 0.3,
        r: 1.2 + Math.random()*2.4,
        life: 1.0
      });
    }
  }

  function updateBits(){
    for(let i=bits.length-1;i>=0;i--){
      const b=bits[i];
      b.vx *= 0.992;
      b.vy = b.vy*0.992 + state.grav*0.35;
      b.x += b.vx;
      b.y += b.vy;
      b.life -= 0.010 + (state.mobileSafe? 0.004 : 0.0);
      if(b.x<-50 || b.x>W+50 || b.y>H+80 || b.life<=0) bits.splice(i,1);
    }
  }

  // ---------- pointer ----------
  const pointer = { x: W/2, y: H/2, down:false, shift:false };
  let lastX=0,lastY=0,lastT=0, dragAccent=0;

  function setPointer(e){
    const r=canvas.getBoundingClientRect();
    pointer.x = e.clientX - r.left;
    pointer.y = e.clientY - r.top;
  }
  function updateDragAccent(){
    const now=performance.now();
    const dt = Math.max(8, now-lastT);
    const dx = pointer.x-lastX, dy=pointer.y-lastY;
    const v = Math.hypot(dx,dy)/dt;
    dragAccent = clamp(v*1.8, 0, 1);
    lastX=pointer.x; lastY=pointer.y; lastT=now;
  }

  function cutLinks(x,y,r){
    const rr=r*r;
    for(const l of links){
      if(!l.active) continue;
      const ax=l.a.x, ay=l.a.y, bx=l.b.x, by=l.b.y;
      const vx=bx-ax, vy=by-ay;
      const wx=x-ax, wy=y-ay;
      const c2=vx*vx+vy*vy;
      let t = c2===0?0:(wx*vx+wy*vy)/c2;
      t = clamp(t,0,1);
      const px=ax+t*vx, py=ay+t*vy;
      const dx=x-px, dy=y-py;
      if(dx*dx+dy*dy<=rr){
        l.active=false;
        spawnTearBits(ax,ay,bx,by);
      }
    }
  }

  function applyField(){
    if(!pointer.down) return;
    const cx=pointer.x, cy=pointer.y;
    const R = SPACING*5.2;
    const R2 = R*R;

    // react controls how strong
    const strength = (state.react/100) * (state.mobileSafe? 2.4 : 3.0);

    for(const p of points){
      if(p.pinned) continue;
      const dx=p.x-cx, dy=p.y-cy;
      const d2=dx*dx+dy*dy;
      if(d2>R2) continue;
      const d=Math.sqrt(d2) || 0.0001;
      const t=1-(d/R);
      const s=(t*t)*strength*(1.0+dragAccent*0.8);
      const nx=dx/d, ny=dy/d;
      p.x  += nx*s*6; p.y  += ny*s*6;
      p.px += nx*s*3; p.py += ny*s*3;
    }
  }

  function toggleCellAt(x,y){
    const band = grooveBandRect();
    const inBand = x>=band.x && x<=band.x+band.w && y>=band.y && y<=band.y+band.h;
    if(!inBand) return false;

    const col = clamp(Math.floor(((x-band.x)/band.w)*STEPS), 0, STEPS-1);
    const row = clamp(Math.floor(((y-band.y)/band.h)*TRACKS), 0, TRACKS-1);

    if(state.erase) pattern[row][col]=0;
    else pattern[row][col] = pattern[row][col]?0:1;
    return true;
  }

  function paintGroove(){
    if(!pointer.down) return;

    // if inside band: precise
    const band = grooveBandRect();
    const inBand = pointer.x>=band.x && pointer.x<=band.x+band.w && pointer.y>=band.y && pointer.y<=band.y+band.h;
    if(inBand){
      const col = clamp(Math.floor(((pointer.x-band.x)/band.w)*STEPS), 0, STEPS-1);
      const row = clamp(Math.floor(((pointer.y-band.y)/band.h)*TRACKS), 0, TRACKS-1);
      pattern[row][col] = state.erase ? 0 : 1;
      return;
    }

    // outside: creative brush (so you can “groove anywhere”)
    const col = clamp(Math.floor((pointer.x/W)*STEPS), 0, STEPS-1);
    const baseRow = clamp(Math.floor((pointer.y/H)*TRACKS), 0, TRACKS-1);

    const stepBrush = 1 + Math.floor(dragAccent*2);     // 1..3
    const trackSpread = dragAccent>0.55 ? 1 : 0;        // 0..1

    for(let dc=-stepBrush; dc<=stepBrush; dc++){
      const s=(col+dc+STEPS)%STEPS;
      const edge = Math.abs(dc)/(stepBrush||1);
      const prob = 1 - 0.55*edge;
      if(Math.random()>prob) continue;

      for(let dr=-trackSpread; dr<=trackSpread; dr++){
        const r=clamp(baseRow+dr,0,TRACKS-1);
        // bias per track
        let bias=1.0;
        if(r===0) bias=0.55;
        if(r===1) bias=0.65;
        if(r===2) bias=1.00;
        if(r===3) bias=0.92;
        if(r===4) bias=0.75;
        if(Math.random()>bias) continue;
        pattern[r][s] = state.erase ? 0 : 1;
      }
    }
  }

  canvas.addEventListener('pointerdown', (e)=>{
    setPointer(e);
    pointer.down=true;
    pointer.shift=!!e.shiftKey;

    lastX=pointer.x; lastY=pointer.y; lastT=performance.now();
    dragAccent=0;

    // tap in band toggles immediately
    toggleCellAt(pointer.x,pointer.y);

    if(state.cut || pointer.shift) cutLinks(pointer.x,pointer.y,state.cutRadius);
    try{ canvas.setPointerCapture(e.pointerId); }catch{}
  }, {passive:true});

  canvas.addEventListener('pointermove', (e)=>{
    setPointer(e);
    pointer.shift=!!e.shiftKey;
    if(pointer.down) updateDragAccent();
    if(pointer.down && (state.cut || pointer.shift)) cutLinks(pointer.x,pointer.y,state.cutRadius);
  }, {passive:true});

  canvas.addEventListener('pointerup', (e)=>{
    pointer.down=false;
    dragAccent*=0.5;
    try{ canvas.releasePointerCapture(e.pointerId); }catch{}
  }, {passive:true});

  if(!("PointerEvent" in window)){
    const getT = (e)=>e.touches && e.touches[0] ? e.touches[0] : null;
    canvas.addEventListener('touchstart', (e)=>{
      const t=getT(e); if(!t) return;
      e.preventDefault();
      setPointer(t);
      pointer.down=true;
      lastX=pointer.x; lastY=pointer.y; lastT=performance.now();
      toggleCellAt(pointer.x,pointer.y);
    }, {passive:false});
    canvas.addEventListener('touchmove', (e)=>{
      const t=getT(e); if(!t) return;
      e.preventDefault();
      setPointer(t);
      updateDragAccent();
    }, {passive:false});
    canvas.addEventListener('touchend', (e)=>{
      e.preventDefault();
      pointer.down=false;
      dragAccent*=0.5;
    }, {passive:false});
  }

  // double tap/click = reset cloth + keep groove
  let lastTap=0;
  canvas.addEventListener('pointerup', ()=>{
    const now=performance.now();
    if(now-lastTap<320){
      rebuildCloth();
    }
    lastTap=now;
  }, {passive:true});

  // ---------- Audio engine + recording ----------
  let audio=null;

  function createAudio(){
    const AC = window.AudioContext || window.webkitAudioContext;
    if(!AC) throw new Error("AudioContext non supportato.");

    const ac = new AC({ latencyHint:"interactive" });

    const master = ac.createGain();
    master.gain.value = 0.42;

    // Connect to destination
    master.connect(ac.destination);

    // noise buffer
    const noiseBuf = ac.createBuffer(1, ac.sampleRate*1.0, ac.sampleRate);
    const data = noiseBuf.getChannelData(0);
    for(let i=0;i<data.length;i++) data[i]=Math.random()*2-1;

    function envGain(t, a, d, peak){
      const g = ac.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(peak, t+a);
      g.gain.exponentialRampToValueAtTime(0.0001, t+a+d);
      return g;
    }
    const pan = (p)=>{
      const pn = ac.createStereoPanner();
      pn.pan.value=p;
      return pn;
    }

    function kick(t){
      const o=ac.createOscillator(); o.type="sine";
      const g=envGain(t,0.003,0.20,1.0);
      o.frequency.setValueAtTime(120,t);
      o.frequency.exponentialRampToValueAtTime(48,t+0.20);
      o.connect(g).connect(pan(-0.05)).connect(master);
      o.start(t); o.stop(t+0.28);
    }
    function clap(t){
      const src=ac.createBufferSource(); src.buffer=noiseBuf;
      const bp=ac.createBiquadFilter(); bp.type="bandpass"; bp.frequency.value=2400; bp.Q.value=0.9;
      const g=envGain(t,0.002,0.11,0.65);
      src.connect(bp).connect(g).connect(pan(0.15)).connect(master);
      src.start(t); src.stop(t+0.14);
    }
    function shaker(t, accent=1){
      const src=ac.createBufferSource(); src.buffer=noiseBuf;
      const hp=ac.createBiquadFilter(); hp.type="highpass"; hp.frequency.value=7200; hp.Q.value=0.8;
      const g=envGain(t,0.001,0.035,0.18*accent);
      src.connect(hp).connect(g).connect(pan(-0.25)).connect(master);
      src.start(t); src.stop(t+0.06);
    }
    function conga(t, accent=1){
      const o=ac.createOscillator(); o.type="sine";
      const g=envGain(t,0.002,0.12,0.30*accent);
      o.frequency.setValueAtTime(200,t);
      o.frequency.exponentialRampToValueAtTime(125,t+0.10);
      o.connect(g).connect(pan(0.28)).connect(master);
      o.start(t); o.stop(t+0.18);
    }
    function bass(t, step){
      const o=ac.createOscillator(); o.type="triangle";
      const g=envGain(t,0.003,0.26,0.30);
      const notes=[55,55,65.4,73.4,65.4,55,49,55];
      o.frequency.setValueAtTime(notes[step%notes.length],t);
      const lp=ac.createBiquadFilter(); lp.type="lowpass"; lp.frequency.value=180; lp.Q.value=0.8;
      o.connect(lp).connect(g).connect(pan(0.02)).connect(master);
      o.start(t); o.stop(t+0.32);
    }

    // ---- scheduler
    let step=0;
    let nextTime=0;
    const lookahead=0.10;
    const interval=25;
    let timer=null;

    function schedule(){
      const spb = 60/state.bpm;
      const baseStep = spb/4;
      while(nextTime < ac.currentTime + lookahead){
        const isOff = (step%2)===1;
        const swingOffset = isOff ? (baseStep*(state.swing-0.5)) : 0;
        const t = nextTime + swingOffset;

        if(pattern[0][step]) kick(t);
        if(pattern[1][step]) clap(t);
        if(pattern[2][step]) shaker(t, 0.9 + 0.7*dragAccent);
        if(pattern[3][step]) conga(t, 0.85 + 0.8*dragAccent);
        if(pattern[4][step]) bass(t, step);

        step = (step+1)%STEPS;
        nextTime += baseStep;
      }
    }
    function start(){
      if(timer) return;
      nextTime = ac.currentTime + 0.05;
      timer = setInterval(schedule, interval);
    }
    function stop(){
      if(timer){ clearInterval(timer); timer=null; }
    }
    const isRunning = ()=>!!timer;

    // ---- recorder (stereo tap after master)
    const rec = {
      node:null, bufsL:[], bufsR:[], isRec:false, sampleRate: ac.sampleRate,
      recStartPerf: 0
    };

    rec.node = ac.createScriptProcessor(4096, 2, 2);
    rec.node.onaudioprocess = (e)=>{
      if(!rec.isRec) return;
      const in0 = e.inputBuffer.getChannelData(0);
      const has1 = e.inputBuffer.numberOfChannels>1;
      const in1 = has1 ? e.inputBuffer.getChannelData(1) : in0;
      rec.bufsL.push(new Float32Array(in0));
      rec.bufsR.push(new Float32Array(in1));
    };

    // silent sink (keep processor alive on Safari)
    const sink = ac.createGain(); sink.gain.value=0.0;
    master.connect(rec.node);
    rec.node.connect(sink);
    sink.connect(ac.destination);

    function encodeWAVStereo(bufsL, bufsR, sampleRate){
      let len=0; for(const b of bufsL) len+=b.length;
      const interleaved = new Int16Array(len*2);
      let o=0;
      for(let i=0;i<bufsL.length;i++){
        const L=bufsL[i], R=bufsR[i]||L;
        for(let n=0;n<L.length;n++){
          let sL=clamp(L[n],-1,1), sR=clamp(R[n],-1,1);
          interleaved[o++] = (sL<0 ? sL*0x8000 : sL*0x7FFF)|0;
          interleaved[o++] = (sR<0 ? sR*0x8000 : sR*0x7FFF)|0;
        }
      }
      const wav = new ArrayBuffer(44 + interleaved.length*2);
      const view = new DataView(wav);
      const ws=(p,s)=>{ for(let i=0;i<s.length;i++) view.setUint8(p+i, s.charCodeAt(i)); };
      const numCh=2, bits=16, blockAlign=numCh*(bits/8), byteRate=sampleRate*blockAlign;

      ws(0,"RIFF"); view.setUint32(4, 36+interleaved.length*2, true); ws(8,"WAVE");
      ws(12,"fmt "); view.setUint32(16,16,true); view.setUint16(20,1,true);
      view.setUint16(22,numCh,true); view.setUint32(24,sampleRate,true);
      view.setUint32(28,byteRate,true); view.setUint16(32,blockAlign,true); view.setUint16(34,bits,true);
      ws(36,"data"); view.setUint32(40,interleaved.length*2,true);

      let p=44;
      for(let i=0;i<interleaved.length;i++,p+=2) view.setInt16(p, interleaved[i], true);
      return new Blob([view], {type:"audio/wav"});
    }

    function startRec(){
      rec.bufsL.length=0; rec.bufsR.length=0;
      rec.isRec=true;
      rec.recStartPerf = performance.now();
    }
    function stopRec(){
      rec.isRec=false;
      const blob = encodeWAVStereo(rec.bufsL, rec.bufsR, rec.sampleRate);
      rec.bufsL.length=0; rec.bufsR.length=0;
      return blob;
    }
    const isRecRunning = ()=>rec.isRec;
    const recElapsedMs = ()=> rec.isRec ? (performance.now()-rec.recStartPerf) : 0;

    return { ac, start, stop, isRunning, startRec, stopRec, isRecRunning, recElapsedMs };
  }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href=url; a.download=filename;
    document.body.appendChild(a);
    a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
  }

  async function ensureAudioRunning(){
    if(!audio){
      audio = createAudio();
      await audio.ac.resume();
      audio.start();
      return;
    }
    await audio.ac.resume();
    if(!audio.isRunning()) audio.start();
  }

  // ---------- UI handlers ----------
  function syncUI(){
    bpmOut.textContent = state.bpm;
    swOut.textContent  = state.swing.toFixed(2);

    cutBtn.classList.toggle("active", state.cut);
    cutBtn.textContent = state.cut ? "CUT: ON" : "CUT: OFF";

    eraseBtn.classList.toggle("active", state.erase);
    eraseBtn.textContent = state.erase ? "ERASE: ON" : "ERASE: OFF";

    // menu outs
    piecesOut.textContent = state.piecesMax;
    reactOut.textContent  = state.react;
    gravOut.textContent   = fmt2(state.grav);
    windOut.textContent   = fmt2(state.wind);
    trailOut.textContent  = fmt2(state.trail);
    glowOut.textContent   = fmt2(state.glow);
    cutrOut.textContent   = state.cutRadius|0;

    mobileSafeEl.checked = state.mobileSafe;
  }

  bpmSlider.addEventListener('input', ()=>{ state.bpm=+bpmSlider.value; bpmOut.textContent=state.bpm; });
  swSlider.addEventListener('input', ()=>{ state.swing=+swSlider.value; swOut.textContent=state.swing.toFixed(2); });

  audioBtn.addEventListener('click', async ()=>{
    try{
      logErr("");
      if(!audio){
        audio = createAudio();
        await audio.ac.resume();
        audio.start();
        audioBtn.textContent = "■ STOP AUDIO";
        setStatePill("PLAYING");
        return;
      }
      if(audio.isRunning()){
        audio.stop();
        audioBtn.textContent = "▶ START AUDIO";
        setStatePill("PAUSED");
      }else{
        await audio.ac.resume();
        audio.start();
        audioBtn.textContent = "■ STOP AUDIO";
        setStatePill("PLAYING");
      }
    }catch(err){
      logErr("Audio: " + err);
    }
  });

  cutBtn.addEventListener('click', ()=>{
    state.cut=!state.cut;
    syncUI();
  });

  eraseBtn.addEventListener('click', ()=>{
    state.erase=!state.erase;
    syncUI();
  });

  afroBtn.addEventListener('click', ()=> seedAfro());
  clearBtn.addEventListener('click', ()=>{ for(let r=0;r<TRACKS;r++) pattern[r].fill(0); });
  resetBtn.addEventListener('click', ()=>{
    seedAfro();
    rebuildCloth();
  });

  // menu open/close
  function openMenu(){ overlay.classList.add("show"); }
  function closeMenu(){ overlay.classList.remove("show"); }
  menuBtn.addEventListener('click', openMenu);
  closeMenuBtn.addEventListener('click', closeMenu);
  overlay.addEventListener('pointerdown', closeMenu, {passive:true});

  helpBtn.addEventListener('click', ()=>{
    logErr(
`Comandi:
• Drag sul cloth = spinta/void
• Band in basso = groove editor (tap = toggle, drag = paint)
• CUT ON (o Shift) = strappi
• ERASE ON = cancella groove
• Doppio tap/click sul canvas = rebuild cloth
Audio:
• START AUDIO poi REC (su iPhone è obbligatorio il gesto)`
    );
    closeMenu();
  });

  panicBtn.addEventListener('click', ()=>{
    state.cut=false; state.erase=false;
    state.mobileSafe=isMobile;
    state.react=55; state.grav=0.42; state.wind=0; state.trail=0.70; state.glow=0.55;
    state.cutRadius=18; state.piecesMax=140;
    piecesEl.value=state.piecesMax;
    reactEl.value=state.react;
    gravEl.value=Math.round(state.grav*100);
    windEl.value=Math.round(state.wind*100);
    trailEl.value=Math.round(state.trail*100);
    glowEl.value=Math.round(state.glow*100);
    cutrEl.value=state.cutRadius;
    resize(); rebuildCloth(); syncUI();
    closeMenu();
  });

  // menu sliders
  mobileSafeEl.addEventListener('change', ()=>{
    state.mobileSafe = !!mobileSafeEl.checked;
    resize(); rebuildCloth(); syncUI();
  });

  piecesEl.addEventListener('input', ()=>{ state.piecesMax=+piecesEl.value; piecesOut.textContent=state.piecesMax; });
  reactEl.addEventListener('input',  ()=>{ state.react=+reactEl.value; reactOut.textContent=state.react; });
  gravEl.addEventListener('input',   ()=>{ state.grav=(+gravEl.value)/100; gravOut.textContent=fmt2(state.grav); });
  windEl.addEventListener('input',   ()=>{ state.wind=(+windEl.value)/100; windOut.textContent=fmt2(state.wind); });
  trailEl.addEventListener('input',  ()=>{ state.trail=(+trailEl.value)/100; trailOut.textContent=fmt2(state.trail); });
  glowEl.addEventListener('input',   ()=>{ state.glow=(+glowEl.value)/100; glowOut.textContent=fmt2(state.glow); });
  cutrEl.addEventListener('input',   ()=>{ state.cutRadius=+cutrEl.value; cutrOut.textContent=state.cutRadius|0; });

  // REC live with timer
  let recTimerRAF = 0;
  function startRecTimer(){
    recPill.style.display = "inline-block";
    const tick=()=>{
      if(!audio || !audio.isRecRunning()){
        recPill.style.display="none";
        cancelAnimationFrame(recTimerRAF);
        return;
      }
      const ms = audio.recElapsedMs();
      const s = Math.floor(ms/1000);
      const mm = String(Math.floor(s/60)).padStart(2,'0');
      const ss = String(s%60).padStart(2,'0');
      recPill.textContent = `REC ${mm}:${ss}`;
      recTimerRAF = requestAnimationFrame(tick);
    };
    recTimerRAF = requestAnimationFrame(tick);
  }

  recBtn.addEventListener('click', async ()=>{
    try{
      logErr("");
      await ensureAudioRunning();
      audioBtn.textContent = "■ STOP AUDIO";
      setStatePill("PLAYING");

      if(audio.isRecRunning()) return;

      audio.startRec();
      recBtn.classList.add("active");
      recBtn.textContent = "● REC…";
      stopRecBtn.style.display = "inline-flex";
      startRecTimer();
    }catch(err){
      logErr("REC: " + err);
    }
  });

  stopRecBtn.addEventListener('click', ()=>{
    try{
      if(!audio || !audio.isRecRunning()) return;
      const blob = audio.stopRec();

      const stamp = new Date().toISOString().replace(/[:.]/g,'-');
      const name = `wirecloth_${state.bpm}bpm_${stamp}.wav`;
      downloadBlob(blob, name);

      recBtn.classList.remove("active");
      recBtn.textContent = "● REC";
      stopRecBtn.style.display = "none";
      recPill.style.display = "none";
    }catch(err){
      logErr("STOP: " + err);
    }
  });

  // REC 4 bars (deterministic)
  rec4Btn.addEventListener('click', async ()=>{
    try{
      logErr("");
      await ensureAudioRunning();
      audioBtn.textContent = "■ STOP AUDIO";
      setStatePill("PLAYING");

      if(audio.isRecRunning()) return;

      audio.startRec();
      recBtn.classList.add("active");
      recBtn.textContent = "● REC…";
      stopRecBtn.style.display = "inline-flex";
      startRecTimer();

      // 4 bars in 4/4 -> 16 beats -> duration seconds = 16*(60/bpm)
      const dur = 16 * (60/state.bpm);
      setTimeout(()=>{
        if(!audio || !audio.isRecRunning()) return;
        const blob = audio.stopRec();
        const stamp = new Date().toISOString().replace(/[:.]/g,'-');
        downloadBlob(blob, `wirecloth_4bars_${state.bpm}bpm_${stamp}.wav`);

        recBtn.classList.remove("active");
        recBtn.textContent = "● REC";
        stopRecBtn.style.display = "none";
        recPill.style.display = "none";
      }, Math.max(250, dur*1000));
    }catch(err){
      logErr("REC 4: " + err);
    }
  });

  // ---------- rendering ----------
  function drawBackground(){
    // trail fill (lower = more persistence)
    const a = clamp(1.0 - state.trail, 0.02, 1.0);
    ctx.fillStyle = `rgba(5,8,5,${a})`;
    ctx.fillRect(0,0,W,H);

    // subtle scanlines
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = "#0b1b0f";
    for(let y=0;y<H;y+=6) ctx.fillRect(0,y,W,1);
    ctx.globalAlpha = 1;
  }

  function drawGrooveBand(playStep){
    const band = grooveBandRect();

    ctx.fillStyle = 'rgba(0,0,0,0.30)';
    ctx.fillRect(band.x, band.y, band.w, band.h);

    // grid
    ctx.strokeStyle = 'rgba(120,255,140,0.16)';
    ctx.lineWidth = 1;
    for(let s=0;s<=STEPS;s++){
      const x = band.x + (s/STEPS)*band.w;
      ctx.beginPath(); ctx.moveTo(x, band.y); ctx.lineTo(x, band.y+band.h); ctx.stroke();
    }
    for(let r=0;r<=TRACKS;r++){
      const y = band.y + (r/TRACKS)*band.h;
      ctx.beginPath(); ctx.moveTo(band.x, y); ctx.lineTo(band.x+band.w, y); ctx.stroke();
    }

    // cells
    const cw = band.w/STEPS, ch = band.h/TRACKS;
    for(let r=0;r<TRACKS;r++){
      for(let s=0;s<STEPS;s++){
        if(!pattern[r][s]) continue;
        const x0 = band.x + s*cw;
        const y0 = band.y + r*ch;
        ctx.fillStyle = 'rgba(120,255,140,0.26)';
        ctx.fillRect(x0+2,y0+2,cw-4,ch-4);
      }
    }

    // labels left (K C S G B)
    ctx.globalAlpha = 0.65;
    ctx.fillStyle = '#b6ffbf';
    ctx.font = '12px -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial';
    const labels = ["K","C","S","G","B"];
    for(let r=0;r<TRACKS;r++){
      ctx.fillText(labels[r], band.x-12, band.y + (r+0.7)*ch);
    }
    ctx.globalAlpha = 1;

    // playhead
    if(audio && audio.isRunning()){
      const x = band.x + (playStep/STEPS)*band.w;
      ctx.strokeStyle = 'rgba(180,255,200,0.60)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(x, band.y); ctx.lineTo(x, band.y+band.h); ctx.stroke();
    }
  }

  function drawCloth(){
    ctx.save();
    // glow
    const g = state.glow;
    ctx.shadowColor = 'rgba(120,255,140,0.55)';
    ctx.shadowBlur  = g>0 ? (g*12) : 0;

    for(const l of links){
      if(!l.active) continue;
      const ax=l.a.x, ay=l.a.y, bx=l.b.x, by=l.b.y;
      const d=Math.hypot(bx-ax, by-ay);
      const t=clamp(d/l.rest,0.7,1.6);
      const w=clamp((2.2-(t-0.7))*1.15, 0.75, 2.6);
      ctx.lineWidth = w;
      ctx.strokeStyle = 'rgba(120,255,140,0.86)';
      ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
    }
    ctx.restore();
  }

  function drawBits(){
    if(bits.length===0) return;
    ctx.save();
    ctx.shadowColor = 'rgba(120,255,140,0.45)';
    ctx.shadowBlur = state.glow*10;
    for(const b of bits){
      ctx.globalAlpha = clamp(b.life,0,1)*0.85;
      ctx.fillStyle = 'rgba(160,255,190,0.9)';
      ctx.beginPath();
      ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function frame(){
    drawBackground();

    // physics
    for(const p of points) p.verlet();
    if(pointer.down){
      if(state.cut || pointer.shift) cutLinks(pointer.x,pointer.y,state.cutRadius);
      else applyField();
      paintGroove();
    }

    for(let k=0;k<ITER;k++){
      for(const l of links) l.satisfy();
      for(const p of points){
        if(p.pinned) continue;
        p.x = clamp(p.x, 2, W-2);
        p.y = clamp(p.y, 2, H-2);
      }
    }

    updateBits();

    // derive a play step for visual playhead (approx; scheduler uses audio time)
    let playStep = 0;
    if(audio && audio.isRunning()){
      const t = (performance.now()/1000) * (state.bpm/60) * 4;
      playStep = (Math.floor(t) % STEPS);
    }

    drawCloth();
    drawBits();
    drawGrooveBand(playStep);

    // pointer dot
    ctx.fillStyle = (state.cut || pointer.shift) ? 'rgba(255,180,80,0.9)' : 'rgba(180,255,200,0.9)';
    ctx.beginPath(); ctx.arc(pointer.x,pointer.y,4,0,Math.PI*2); ctx.fill();

    requestAnimationFrame(frame);
  }

  // ---------- init ----------
  bpmSlider.value = state.bpm;
  swSlider.value = state.swing;
  piecesEl.value = state.piecesMax;
  reactEl.value = state.react;
  gravEl.value = Math.round(state.grav*100);
  windEl.value = Math.round(state.wind*100);
  trailEl.value = Math.round(state.trail*100);
  glowEl.value = Math.round(state.glow*100);
  cutrEl.value = state.cutRadius;

  resize();
  rebuildCloth();
  syncUI();
  setStatePill("READY");

  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
