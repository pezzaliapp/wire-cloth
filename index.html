<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Wire Cloth + Afro Groove — Single File</title>
  <style>
    :root{
      --bg:#050805;
      --fg:#b6ffbf;
      --fg2:#d7ffdd;
      --panel:rgba(0,0,0,.35);
      --border:rgba(182,255,191,.18);
      --btn:rgba(0,0,0,.25);
      --btnOn:rgba(56,140,74,.35);
      --btnBorder:rgba(182,255,191,.25);
      --btnBorderOn:rgba(125,255,160,.35);
    }
    html,body{margin:0;height:100%;background:var(--bg);overflow:hidden;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;color:var(--fg)}
    canvas{
      position:fixed;inset:0;width:100vw;height:100vh;display:block;
      touch-action:none; /* CRITICO iOS */
      -webkit-user-select:none; user-select:none;
      -webkit-tap-highlight-color:transparent;
    }
    .hud{
      position:fixed;left:12px;top:12px;
      width:min(640px,calc(100vw - 24px));
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      padding:12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 8px 40px rgba(0,0,0,.35);
    }
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .title{font-weight:800;letter-spacing:.2px}
    .badge{
      display:inline-flex;align-items:center;gap:8px;
      font-size:12px;opacity:.95;
      padding:6px 10px;border-radius:999px;
      border:1px solid rgba(182,255,191,.25);
      background:rgba(0,0,0,.25);
      white-space:nowrap;
    }
    button{
      background:var(--btn);
      border:1px solid var(--btnBorder);
      color:var(--fg2);
      border-radius:14px;
      padding:10px 12px;
      font-weight:700;
      letter-spacing:.2px;
      cursor:pointer;
      -webkit-appearance:none;
      appearance:none;
    }
    button.on{
      background:var(--btnOn);
      border-color:var(--btnBorderOn);
    }
    .slider{
      display:flex;align-items:center;gap:10px;
      width:100%;
      margin-top:10px;
    }
    .slider label{min-width:78px;opacity:.95}
    input[type="range"]{flex:1}
    .hint{margin-top:10px;font-size:12px;opacity:.82;line-height:1.35}
    .small{font-size:12px;opacity:.88}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;background:rgba(0,0,0,.25);border:1px solid rgba(182,255,191,.15);padding:2px 6px;border-radius:8px}
  </style>
</head>

<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="row" style="justify-content:space-between">
      <div class="title">Wire Cloth + Afro Groove</div>
      <div class="badge" id="modeBadge">MODE: …</div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="btnAudio">AUDIO</button>
      <button id="btnErase" class="on">ERASE: ON</button>
      <button id="btnRec">REC WAV</button>
      <button id="btnAfro" class="on">AFRO</button>
      <button id="btnClear">CLEAR</button>
      <button id="btnReset">RESET</button>
      <button id="btnForce">Force Mobile: OFF</button>
    </div>

    <div class="slider">
      <label>BPM <b id="bpmVal">115</b></label>
      <input id="bpm" type="range" min="80" max="150" value="115" step="1">
      <span class="small">Swing <b id="swVal">0.58</b></span>
      <input id="sw" type="range" min="0.45" max="0.65" value="0.58" step="0.01">
    </div>

    <div class="slider">
      <label>Mem <b id="memVal">0.65</b></label>
      <input id="mem" type="range" min="0.2" max="0.95" value="0.65" step="0.01">
      <span class="small">React <b id="reactVal">0.55</b></span>
      <input id="react" type="range" min="0.1" max="0.95" value="0.55" step="0.01">
    </div>

    <div class="slider">
      <label>Trail <b id="trailVal">0.70</b></label>
      <input id="trail" type="range" min="0.0" max="0.95" value="0.70" step="0.01">
      <span class="small">Glow <b id="glowVal">0.55</b></span>
      <input id="glow" type="range" min="0.0" max="0.95" value="0.55" step="0.01">
    </div>

    <div class="hint" id="hint">
      <b>Touch:</b> hold &amp; drag = crea vuoti + groove • tap sulla band = toggle cella • doppio tap = reset<br>
      <span class="small">Desktop: <span class="kbd">Shift</span> durante drag = taglio più aggressivo.</span>
    </div>
  </div>

<script>
/* =========================================================
   Single-file: Canvas + Verlet cloth + Groove sequencer
   Mobile safe: Pointer Events + touch-action none + passive:false
   ========================================================= */

(() => {
  // ---------- DOM ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

  const $ = (id) => document.getElementById(id);

  const btnAudio = $('btnAudio');
  const btnErase = $('btnErase');
  const btnRec   = $('btnRec');
  const btnAfro  = $('btnAfro');
  const btnClear = $('btnClear');
  const btnReset = $('btnReset');
  const btnForce = $('btnForce');

  const bpmEl = $('bpm'), bpmVal = $('bpmVal');
  const swEl  = $('sw'),  swVal  = $('swVal');
  const memEl = $('mem'), memVal = $('memVal');
  const reactEl = $('react'), reactVal = $('reactVal');
  const trailEl = $('trail'), trailVal = $('trailVal');
  const glowEl  = $('glow'),  glowVal  = $('glowVal');

  const modeBadge = $('modeBadge');

  // ---------- Resize ----------
  let W=0, H=0, DPR=1;
  function resize(){
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height= Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height= H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize, { passive:true });
  resize();

  // ---------- Profile detection ----------
  let forceMobile = false;
  function computeProfile(){
    const isCoarse = matchMedia("(pointer: coarse)").matches;
    const noHover  = matchMedia("(hover: none)").matches;
    const smallScreen = Math.min(window.innerWidth, window.innerHeight) < 820;
    const mobile = forceMobile || (isCoarse && noHover && smallScreen);
    return mobile ? "mobile" : "desktop";
  }
  let PROFILE = computeProfile();

  // ---------- Controls state ----------
  let BPM = +bpmEl.value;
  let SWING = +swEl.value;

  let MEM = +memEl.value;      // "memory" of cloth motion
  let REACT = +reactEl.value;  // how much groove hits shake cloth
  let TRAIL = +trailEl.value;  // persistence of frame
  let GLOW = +glowEl.value;    // line intensity

  let eraseOn = true;
  let afroOn = true;
  let audioOn = false;

  // ---------- Sequencer ----------
  const LANES = [
    { key:'K', name:'Kick' },
    { key:'C', name:'Clap' },
    { key:'S', name:'Snare' },
    { key:'G', name:'Conga' },
    { key:'B', name:'Bass' },
  ];
  const STEPS = 16;
  let grid = Array.from({length: LANES.length}, () => Array(STEPS).fill(0));
  let step = 0;
  let playPhase = 0; // 0..1
  let lastTick = performance.now();

  // band geometry (computed each frame)
  function bandRect(){
    const bandH = Math.max(160, Math.floor(H * 0.28));
    const y0 = H - bandH;
    return { x0: 0, y0, w: W, h: bandH };
  }

  function setAfroPreset(on){
    afroOn = on;
    if(!afroOn) return;
    // Afro-ish: kick 1, "and" patterns, clap/snare backbeat, conga shuffle, bass sparse
    for(let r=0;r<LANES.length;r++) grid[r].fill(0);

    // Kick
    [0, 3, 7, 10, 12].forEach(i=>grid[0][i]=1);
    // Clap
    [4, 12].forEach(i=>grid[1][i]=1);
    // Snare (lighter)
    [8].forEach(i=>grid[2][i]=1);
    // Conga (busy)
    [2,5,6,9,11,14,15].forEach(i=>grid[3][i]=1);
    // Bass
    [0, 6, 10, 12].forEach(i=>grid[4][i]=1);
  }
  setAfroPreset(true);

  // ---------- Audio (WebAudio) ----------
  let AC = null;
  let master = null;

  function ensureAudio(){
    if(AC) return;
    AC = new (window.AudioContext || window.webkitAudioContext)();
    master = AC.createGain();
    master.gain.value = 0.85;
    master.connect(AC.destination);
  }

  function trigKick(t, vel){
    const o = AC.createOscillator();
    const g = AC.createGain();
    o.type = 'sine';
    o.frequency.setValueAtTime(140, t);
    o.frequency.exponentialRampToValueAtTime(48, t + 0.09);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.9 * vel, t + 0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);
    o.connect(g); g.connect(master);
    o.start(t); o.stop(t + 0.14);
  }

  function noiseBuffer(){
    const len = Math.floor(AC.sampleRate * 0.2);
    const b = AC.createBuffer(1, len, AC.sampleRate);
    const d = b.getChannelData(0);
    for(let i=0;i<len;i++) d[i] = (Math.random()*2-1);
    return b;
  }
  let NOISE = null;

  function trigClap(t, vel){
    if(!NOISE) NOISE = noiseBuffer();
    const src = AC.createBufferSource();
    src.buffer = NOISE;

    const bp = AC.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = 2200;
    bp.Q.value = 0.8;

    const g = AC.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.linearRampToValueAtTime(0.6 * vel, t + 0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);

    src.connect(bp); bp.connect(g); g.connect(master);
    src.start(t); src.stop(t + 0.18);
  }

  function trigSnare(t, vel){
    if(!NOISE) NOISE = noiseBuffer();
    const src = AC.createBufferSource();
    src.buffer = NOISE;

    const hp = AC.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 900;

    const g = AC.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.linearRampToValueAtTime(0.5 * vel, t + 0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);

    src.connect(hp); hp.connect(g); g.connect(master);
    src.start(t); src.stop(t + 0.22);
  }

  function trigConga(t, vel){
    const o = AC.createOscillator();
    const g = AC.createGain();
    o.type = 'triangle';
    o.frequency.setValueAtTime(320, t);
    o.frequency.exponentialRampToValueAtTime(220, t + 0.08);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.35 * vel, t + 0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);
    o.connect(g); g.connect(master);
    o.start(t); o.stop(t + 0.14);
  }

  function trigBass(t, vel){
    const o = AC.createOscillator();
    const g = AC.createGain();
    o.type = 'sawtooth';
    o.frequency.setValueAtTime(55, t);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.18 * vel, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);
    o.connect(g); g.connect(master);
    o.start(t); o.stop(t + 0.22);
  }

  function playStep(now){
    if(!audioOn || !AC) return;
    const t = now;
    // velocity varies with swing / react
    const vel = 0.9;
    if(grid[0][step]) trigKick(t, vel);
    if(grid[1][step]) trigClap(t, vel * 0.9);
    if(grid[2][step]) trigSnare(t, vel * 0.85);
    if(grid[3][step]) trigConga(t, vel * 0.7);
    if(grid[4][step]) trigBass(t, vel * 0.8);
  }

  // ---------- WAV export (offline render 4 bars) ----------
  function floatTo16BitPCM(output, offset, input){
    for (let i=0;i<input.length;i++){
      let s = Math.max(-1, Math.min(1, input[i]));
      output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      offset += 2;
    }
  }
  function writeString(view, offset, string){
    for (let i=0;i<string.length;i++) view.setUint8(offset + i, string.charCodeAt(i));
  }
  function audioBufferToWav(buffer){
    const numCh = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const format = 1; // PCM
    const bitDepth = 16;

    const samples = buffer.length;
    const blockAlign = numCh * bitDepth/8;
    const byteRate = sampleRate * blockAlign;
    const dataSize = samples * blockAlign;

    const ab = new ArrayBuffer(44 + dataSize);
    const view = new DataView(ab);

    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + dataSize, true);
    writeString(view, 8, 'WAVE');
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, format, true);
    view.setUint16(22, numCh, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bitDepth, true);
    writeString(view, 36, 'data');
    view.setUint32(40, dataSize, true);

    let offset = 44;
    // interleave
    const chans = [];
    for(let c=0;c<numCh;c++) chans.push(buffer.getChannelData(c));

    for(let i=0;i<samples;i++){
      for(let c=0;c<numCh;c++){
        let s = Math.max(-1, Math.min(1, chans[c][i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        offset += 2;
      }
    }
    return new Blob([view], { type:'audio/wav' });
  }

  async function renderWav4Bars(){
    ensureAudio();
    const sr = 44100;
    const bars = 4;
    const beatsPerBar = 4;
    const totalBeats = bars * beatsPerBar;
    const secondsPerBeat = 60 / BPM;
    const dur = totalBeats * secondsPerBeat;

    const off = new OfflineAudioContext(2, Math.ceil(sr * dur), sr);

    const out = off.createGain();
    out.gain.value = 0.9;
    out.connect(off.destination);

    // create simple trigger functions in OfflineContext
    const makeNoise = () => {
      const len = Math.floor(sr * 0.25);
      const b = off.createBuffer(1, len, sr);
      const d = b.getChannelData(0);
      for(let i=0;i<len;i++) d[i] = (Math.random()*2-1);
      return b;
    };
    const N = makeNoise();

    const kick = (t, vel) => {
      const o = off.createOscillator();
      const g = off.createGain();
      o.type='sine';
      o.frequency.setValueAtTime(140, t);
      o.frequency.exponentialRampToValueAtTime(48, t+0.09);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.9*vel, t+0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
      o.connect(g); g.connect(out);
      o.start(t); o.stop(t+0.14);
    };
    const clap = (t, vel) => {
      const src = off.createBufferSource(); src.buffer = N;
      const bp = off.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=2200; bp.Q.value=0.8;
      const g = off.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.linearRampToValueAtTime(0.6*vel, t+0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
      src.connect(bp); bp.connect(g); g.connect(out);
      src.start(t); src.stop(t+0.18);
    };
    const sn = (t, vel) => {
      const src = off.createBufferSource(); src.buffer = N;
      const hp = off.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=900;
      const g = off.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.linearRampToValueAtTime(0.5*vel, t+0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
      src.connect(hp); hp.connect(g); g.connect(out);
      src.start(t); src.stop(t+0.22);
    };
    const conga = (t, vel) => {
      const o = off.createOscillator();
      const g = off.createGain();
      o.type='triangle';
      o.frequency.setValueAtTime(320, t);
      o.frequency.exponentialRampToValueAtTime(220, t+0.08);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.35*vel, t+0.004);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
      o.connect(g); g.connect(out);
      o.start(t); o.stop(t+0.14);
    };
    const bass = (t, vel) => {
      const o = off.createOscillator();
      const g = off.createGain();
      o.type='sawtooth';
      o.frequency.setValueAtTime(55, t);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.18*vel, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
      o.connect(g); g.connect(out);
      o.start(t); o.stop(t+0.22);
    };

    // schedule 16th notes over 4 bars
    const totalSteps = bars * STEPS;
    for(let s=0; s<totalSteps; s++){
      const localStep = s % STEPS;
      const beatIndex = (s/4); // each 16th = 1/4 beat
      const baseT = beatIndex * secondsPerBeat;

      // swing: delay odd 16ths
      const odd = (localStep % 2) === 1;
      const swingAmt = (SWING - 0.5) * 0.16 * secondsPerBeat; // subtle
      const t = baseT + (odd ? swingAmt : 0);

      const vel = 0.95;

      if(grid[0][localStep]) kick(t, vel);
      if(grid[1][localStep]) clap(t, vel*0.9);
      if(grid[2][localStep]) sn(t, vel*0.85);
      if(grid[3][localStep]) conga(t, vel*0.7);
      if(grid[4][localStep]) bass(t, vel*0.8);
    }

    const rendered = await off.startRendering();
    const wav = audioBufferToWav(rendered);
    const url = URL.createObjectURL(wav);

    const a = document.createElement('a');
    a.href = url;
    a.download = `wirecloth_afro_${BPM}bpm.wav`;
    document.body.appendChild(a);
    a.click();
    a.remove();

    setTimeout(()=>URL.revokeObjectURL(url), 15000);
  }

  // ---------- Verlet cloth ----------
  // cloth acts as “wire grid” that can be cut by gestures.
  let pts = [];
  let cons = [];

  function makeCloth(){
    pts.length = 0; cons.length = 0;

    PROFILE = computeProfile();

    // profile tuning
    const mobile = PROFILE === "mobile";
    const cols = mobile ? 46 : 72;
    const rows = mobile ? 26 : 40;

    const marginTop = 120;
    const band = bandRect();
    const usableH = (band.y0 - marginTop) - 20;
    const usableW = W - 40;

    const x0 = 20;
    const y0 = marginTop;

    const dx = usableW / (cols - 1);
    const dy = usableH / (rows - 1);

    // points
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const px = x0 + x*dx;
        const py = y0 + y*dy;
        const pin = (y===0) && (x%2===0); // pinned every other top point
        pts.push({
          x:px, y:py,
          ox:px, oy:py,
          vx:0, vy:0,
          pin
        });
      }
    }

    // constraints (grid)
    const idx = (x,y)=> y*cols + x;
    const addC = (a,b,rest)=> cons.push({a,b,rest,broken:false});
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        if(x<cols-1) addC(idx(x,y), idx(x+1,y), dx);
        if(y<rows-1) addC(idx(x,y), idx(x,y+1), dy);
        // diagonal for stiffness (light)
        if(!mobile){
          if(x<cols-1 && y<rows-1) addC(idx(x,y), idx(x+1,y+1), Math.hypot(dx,dy));
          if(x>0 && y<rows-1) addC(idx(x,y), idx(x-1,y+1), Math.hypot(dx,dy));
        }
      }
    }
  }
  makeCloth();

  function verletStep(dt){
    const g = 980; // gravity px/s^2
    const damp = 0.985 * MEM; // memory influences damping

    for(const p of pts){
      if(p.pin) continue;
      const vx = (p.x - p.ox) * damp;
      const vy = (p.y - p.oy) * damp;

      p.ox = p.x; p.oy = p.y;

      p.x += vx;
      p.y += vy + g * dt*dt;

      // bounds (keep inside top area)
      if(p.x < 0) p.x = 0;
      if(p.x > W) p.x = W;
      if(p.y < 0) p.y = 0;
      if(p.y > H) p.y = H;
    }

    // satisfy constraints multiple iterations
    const iters = (PROFILE==="mobile") ? 4 : 7;
    for(let k=0;k<iters;k++){
      for(const c of cons){
        if(c.broken) continue;
        const p1 = pts[c.a], p2 = pts[c.b];
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const dist = Math.hypot(dx,dy) || 1e-6;
        const diff = (dist - c.rest) / dist;

        const stiff = 0.85;
        const offx = dx * 0.5 * stiff * diff;
        const offy = dy * 0.5 * stiff * diff;

        if(!p1.pin){ p1.x += offx; p1.y += offy; }
        if(!p2.pin){ p2.x -= offx; p2.y -= offy; }
      }
    }
  }

  // cloth “shake” when groove hits
  function clothReact(amount){
    const band = bandRect();
    const centerY = band.y0 - 60;
    for(let i=0;i<pts.length;i+=7){
      const p = pts[i];
      if(p.pin) continue;
      const w = Math.max(0, 1 - Math.abs(p.y - centerY) / (band.y0));
      const kick = amount * w * REACT;
      p.y -= kick * 8;
      p.x += (Math.random()*2-1) * kick * 2;
    }
  }

  // cut constraints near pointer
  function cutAt(x,y, radius, aggressive=false){
    const r2 = radius*radius;
    for(const c of cons){
      if(c.broken) continue;
      const p1 = pts[c.a], p2 = pts[c.b];
      const mx = (p1.x + p2.x) * 0.5;
      const my = (p1.y + p2.y) * 0.5;
      const dx = mx - x, dy = my - y;
      const d2 = dx*dx + dy*dy;
      if(d2 < r2){
        // desktop shift => more aggressive
        c.broken = true;
      }else if(aggressive && d2 < r2*1.8){
        c.broken = true;
      }
    }
  }

  // ---------- Input (Pointer Events) ----------
  let pointers = new Map(); // id -> {x,y,down,shift}
  let lastTapTime = 0;

  function canvasXY(e){
    const rect = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left),
      y: (e.clientY - rect.top),
    };
  }

  function toggleCellAt(x,y){
    const band = bandRect();
    if(y < band.y0) return false;
    const laneH = band.h / LANES.length;
    const colW = band.w / STEPS;

    const lane = Math.floor((y - band.y0) / laneH);
    const st = Math.floor((x - band.x0) / colW);

    if(lane<0 || lane>=LANES.length || st<0 || st>=STEPS) return false;
    grid[lane][st] = grid[lane][st] ? 0 : 1;
    return true;
  }

  function paintGrooveAt(x,y){
    // “ovunque”: se l'utente trascina nel band, scrive hit;
    // se trascina sopra, scrive hit sulla lane più vicina al fondo (Conga) + taglia cloth se eraseOn.
    const band = bandRect();
    const laneH = band.h / LANES.length;
    const colW = band.w / STEPS;

    let lane, st;
    st = Math.max(0, Math.min(STEPS-1, Math.floor(x / colW)));

    if(y >= band.y0){
      lane = Math.max(0, Math.min(LANES.length-1, Math.floor((y - band.y0)/laneH)));
    }else{
      // sopra la band: scegli lane in base alla vicinanza al fondo
      lane = 3; // Conga default
    }
    grid[lane][st] = 1;
  }

  function onPointerDown(e){
    // IMPORTANT: preventDefault (iOS) with passive:false via addEventListener options below
    canvas.setPointerCapture(e.pointerId);
    const {x,y} = canvasXY(e);
    pointers.set(e.pointerId, {x,y,down:true,shift:!!e.shiftKey, type:e.pointerType});

    const now = performance.now();
    const isDoubleTap = (now - lastTapTime) < 280;
    lastTapTime = now;

    if(isDoubleTap){
      makeCloth();
      return;
    }

    // quick tap on band toggles a cell
    // (we decide on pointerup too, but this improves feel)
    if(e.pointerType !== 'mouse'){
      // touch: don't rely on click
    }
  }

  function onPointerMove(e){
    const p = pointers.get(e.pointerId);
    if(!p || !p.down) return;
    const {x,y} = canvasXY(e);

    const dx = x - p.x;
    const dy = y - p.y;
    p.x = x; p.y = y;

    // if moving enough => drag action
    const band = bandRect();
    const mobile = PROFILE==="mobile";

    if(eraseOn){
      // cut cloth only above band (avoid accidental cuts when editing groove)
      if(y < band.y0){
        const radius = mobile ? 18 : 14;
        const aggressive = (!!e.shiftKey) || p.shift;
        cutAt(x,y, radius, aggressive);
      }
      // also paint groove while dragging anywhere
      paintGrooveAt(x,y);
    }else{
      // not erasing: just paint groove if within band
      if(y >= band.y0) paintGrooveAt(x,y);
    }
  }

  function onPointerUp(e){
    const p = pointers.get(e.pointerId);
    if(!p) return;

    const {x,y} = canvasXY(e);
    const band = bandRect();

    // Treat as tap if small movement (we don't track full movement per pointer; good enough)
    // On iPhone: pointerup after small movement => toggle cell if in band
    if(y >= band.y0){
      toggleCellAt(x,y);
    }else{
      // tap above band: small “poke”
      if(!eraseOn) paintGrooveAt(x,y);
      if(eraseOn) cutAt(x,y, (PROFILE==="mobile")?16:12, false);
    }

    pointers.delete(e.pointerId);
  }

  // Use passive:false so preventDefault works on iOS Safari
  canvas.addEventListener('pointerdown', (e)=>{ e.preventDefault(); onPointerDown(e); }, { passive:false });
  canvas.addEventListener('pointermove', (e)=>{ e.preventDefault(); onPointerMove(e); }, { passive:false });
  canvas.addEventListener('pointerup',   (e)=>{ e.preventDefault(); onPointerUp(e); },   { passive:false });
  canvas.addEventListener('pointercancel',(e)=>{ e.preventDefault(); pointers.delete(e.pointerId); }, { passive:false });

  // ---------- UI wiring ----------
  function syncUI(){
    bpmVal.textContent = BPM.toString();
    swVal.textContent = SWING.toFixed(2);
    memVal.textContent = MEM.toFixed(2);
    reactVal.textContent = REACT.toFixed(2);
    trailVal.textContent = TRAIL.toFixed(2);
    glowVal.textContent = GLOW.toFixed(2);

    btnErase.classList.toggle('on', eraseOn);
    btnErase.textContent = eraseOn ? 'ERASE: ON' : 'ERASE: OFF';
    btnAfro.classList.toggle('on', afroOn);
    btnAudio.classList.toggle('on', audioOn);

    const prof = computeProfile();
    modeBadge.textContent = `MODE: ${prof.toUpperCase()} • DPR ${DPR.toFixed(2)}`;
    btnForce.classList.toggle('on', forceMobile);
    btnForce.textContent = forceMobile ? 'Force Mobile: ON' : 'Force Mobile: OFF';
  }
  syncUI();

  bpmEl.addEventListener('input', () => { BPM = +bpmEl.value; syncUI(); }, {passive:true});
  swEl.addEventListener('input',  () => { SWING = +swEl.value; syncUI(); }, {passive:true});
  memEl.addEventListener('input', () => { MEM = +memEl.value; syncUI(); }, {passive:true});
  reactEl.addEventListener('input', () => { REACT = +reactEl.value; syncUI(); }, {passive:true});
  trailEl.addEventListener('input', () => { TRAIL = +trailEl.value; syncUI(); }, {passive:true});
  glowEl.addEventListener('input', () => { GLOW = +glowEl.value; syncUI(); }, {passive:true});

  btnErase.addEventListener('click', () => { eraseOn = !eraseOn; syncUI(); }, {passive:true});
  btnAfro.addEventListener('click', () => { setAfroPreset(!afroOn); afroOn = !afroOn; if(afroOn) setAfroPreset(true); syncUI(); }, {passive:true});
  btnClear.addEventListener('click', () => { for(let r=0;r<LANES.length;r++) grid[r].fill(0); syncUI(); }, {passive:true});
  btnReset.addEventListener('click', () => { makeCloth(); syncUI(); }, {passive:true});
  btnForce.addEventListener('click', () => {
    forceMobile = !forceMobile;
    PROFILE = computeProfile();
    makeCloth();
    syncUI();
  }, {passive:true});

  btnAudio.addEventListener('click', async () => {
    ensureAudio();
    if(AC.state === 'suspended') await AC.resume();
    audioOn = !audioOn;
    syncUI();
  }, {passive:true});

  btnRec.addEventListener('click', async () => {
    try{
      await renderWav4Bars();
    }catch(err){
      console.error(err);
      alert('REC WAV non disponibile su questo browser / contesto (serve https).');
    }
  }, {passive:true});

  // ---------- Draw ----------
  function drawGridBand(){
    const band = bandRect();
    const x0=band.x0, y0=band.y0, w=band.w, h=band.h;

    // background band
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#050805';
    ctx.fillRect(x0,y0,w,h);

    // grid lines
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = '#2b6a34';
    ctx.lineWidth = 1;

    const colW = w / STEPS;
    const laneH = h / LANES.length;

    for(let i=0;i<=STEPS;i++){
      ctx.beginPath();
      ctx.moveTo(x0 + i*colW, y0);
      ctx.lineTo(x0 + i*colW, y0 + h);
      ctx.stroke();
    }
    for(let r=0;r<=LANES.length;r++){
      ctx.beginPath();
      ctx.moveTo(x0, y0 + r*laneH);
      ctx.lineTo(x0 + w, y0 + r*laneH);
      ctx.stroke();
    }

    // lane labels left
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = '#b6ffbf';
    ctx.font = '12px -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial';
    for(let r=0;r<LANES.length;r++){
      ctx.fillText(LANES[r].key, 10, y0 + (r+0.72)*laneH);
    }

    // active cells
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#2f8a3c';
    for(let r=0;r<LANES.length;r++){
      for(let c=0;c<STEPS;c++){
        if(!grid[r][c]) continue;
        const px = x0 + c*colW + 2;
        const py = y0 + r*laneH + 2;
        ctx.fillRect(px, py, colW-4, laneH-4);
      }
    }

    // playhead
    ctx.globalAlpha = 0.95;
    ctx.strokeStyle = '#b6ffbf';
    ctx.lineWidth = 2;
    const phx = x0 + (playPhase * w);
    ctx.beginPath();
    ctx.moveTo(phx, y0);
    ctx.lineTo(phx, y0 + h);
    ctx.stroke();

    ctx.restore();
  }

  function drawCloth(){
    // draw constraints as wire
    const intensity = 0.35 + GLOW * 0.55;
    ctx.save();
    ctx.globalAlpha = intensity;
    ctx.strokeStyle = '#76ff93';
    ctx.lineWidth = (PROFILE==="mobile") ? 1 : 1;

    ctx.beginPath();
    for(const c of cons){
      if(c.broken) continue;
      const p1 = pts[c.a], p2 = pts[c.b];
      // skip if in band region (keep clean)
      const band = bandRect();
      if(p1.y >= band.y0 || p2.y >= band.y0) continue;
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
    }
    ctx.stroke();
    ctx.restore();
  }

  // ---------- Transport ----------
  function stepTransport(now){
    const dtMs = now - lastTick;
    lastTick = now;

    // 16th note duration
    const beatMs = (60_000 / BPM);
    const stepMs = beatMs / 4;

    playPhase += dtMs / (stepMs * STEPS);
    while(playPhase >= 1){
      playPhase -= 1;
    }

    // tick step changes based on phase
    const targetStep = Math.floor(playPhase * STEPS) % STEPS;
    if(targetStep !== step){
      step = targetStep;

      // swing scheduling for realtime audio
      if(audioOn && AC){
        const odd = (step % 2) === 1;
        const swingAmt = (SWING - 0.5) * 0.16 * (60 / BPM); // seconds
        const t = AC.currentTime + (odd ? swingAmt : 0);

        playStep(t);

        // cloth reacts to hits (sum lanes)
        let hits = 0;
        for(let r=0;r<LANES.length;r++) hits += grid[r][step] ? 1 : 0;
        if(hits) clothReact(Math.min(1.4, hits * 0.35));
      }
    }
  }

  // ---------- Animation loop ----------
  ctx.fillStyle = '#050805';
  ctx.fillRect(0,0,W,H);

  function frame(now){
    // trails
    if(TRAIL <= 0){
      ctx.fillStyle = '#050805';
      ctx.fillRect(0,0,W,H);
    }else{
      const a = Math.max(0.03, 1 - TRAIL);
      ctx.save();
      ctx.globalAlpha = a;
      ctx.fillStyle = '#050805';
      ctx.fillRect(0,0,W,H);
      ctx.restore();
    }

    // time
    stepTransport(now);

    // physics
    const dt = 1/60;
    verletStep(dt);

    // draw
    drawCloth();
    drawGridBand();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // ---------- Small UX: update badge continuously ----------
  setInterval(() => {
    PROFILE = computeProfile();
    syncUI();
  }, 800);

})();
</script>
</body>
</html>
